

ECE 441
Microprocessors
Instructor:  Dr. Jafar Saniie
Teaching Assistant:  Who?

Final Project Report:
MONITOR PROJECT 
**/**/2018




By:  Clive Gomes

Acknowledgment: I acknowledge all of the work including figures and codes are belongs to me and/or persons who are referenced.


Signature : _____________________________________
Table of Contents


Abstract	2
1-) Introduction	2
2-) Monitor Program	3
2.1-) Command Interpreter	4
2.1.1-) Algorithm and Flowchart	5
2.1.2-) 68000 Assembly Code	5

2.2-) Debugger Commands	6
2.2.1-) Debugger Command # 1	6
2.2.2-) Debugger Command # 2	7
2.2.3-) Debugger Command # 3	7
2.2.4-) Debugger Command # 4	8
2.2.5-) Debugger Command # 5	8
2.2.6-) Debugger Command # 6	9
2.2.7-) Debugger Command # 7	10
2.2.8-) Debugger Command # 8	10
2.2.9-) Debugger Command # 9	11
2.2.10-) Debugger Command # 10	11
2.2.11-) Debugger Command # 11	12
2.2.12-) Debugger Command # 12	12

2.3-)Exception Handlers 	13
2.3.1-) Bus Error Exception	13
2.3.2-) Address Error Exception	14
2.3.3-) Illegal Instruction Exception	14
2.3.4-) Privilege Violation Exception	14
2.3.5-) Divide by Zero Exception	15
2.3.6-) Line A and Line F Emulators 	15
2.4-)User Instructional Manual Exception Handlers 	16
2.4.1-) Help Menu	16

3-) Discussion	17
4-) Feature Suggestions	18
6-) Conclusions	19
7-) References	20






Abstract

Microprocessors are used in almost all technological devices out there. As assembly language is used to code microprocessors, the thought of using these might appear daunting to some users, who might require the processor to perform some basic operations. A Monitor Program enables and empowers such users by providing them a simple interface and a set of commands that they can then use to accomplish their required task. This report serves to discuss, at length, the design and implementation of such a Monitor Program.

1-) Introduction


 This will be an introduction to your design. You can give design objectives, a clear description of the problem and design methodology and technology used.  Any figures and tables should have clear descriptions. 

If your computer communicates with any device, that device probably uses microprocessors. Microprocessors help printers print, scanners scan and Internet modems get you on the Web. When you copy multimedia items from a cell phone to your computer, both devices perform that task using microprocessors [1]. But their most valuable feature is that they are cheap to manufacture, provide great computing power, and can be made small enough to fit in the palm of our hands! The Motorola 68000 Microprocessor is a great example that demonstrates some of the most striking features of microprocessors. Clearly however, just as in the case for any benefial technology, microprocessors come with certain disadvantages. Since the only language a machine understands is that of 0's and 1's, all software programs need to be converted to machine code. A step above that is assembly code, and this is how microprocessors are programmed. It comprises of a set of instructions (which differ in various architectures) that are used to write the software logic, which is they converted to machine code and executed on the microprocessor. Thus, two things are essential for programming and using microprocessors -- the microprocessor hardware (inclusive of power supply, wired connections and so on) and a development environment to write and test the code. A software like Easy68K provides both of these, and is thus a valuable asset for microprocessor programmers.

EASy68K is a 68000 Structured Assembly Language IDE that allows you to edit, assemble and run 68000 programs on a Windows PC or Wine. [2] The most important feature of this software is that one doesn't need to own a physical microprocessor as the simulator performs and covers for all (or most) of the hardware features of a typical 68000 processor. Thus, this is the perfect development environment for beginners and experts alike.




Figure 1.1. Intro 1












Though using the Easy68K takes care of most of the fixable drawbacks of microprocessors, there is yet another issue that needs to be addressed. At times, a user may need (for whatever reason) to test out a piece of memory hardware. They would usually to use a microprocessor to perform this task, but may not have the skill or time to write a program to do so. This is were Monitor Programs gain importance. A Monitor Program has a simple interface, which provides users some of the most common functions (as commands), which they can then use to perform various operations on a memory device, and also test its functionality. Therefore, to address this need of a program as such, a Monitor Program ("TUTOR 0") was developed and this report is intended to provide a general overview of its features as well as in-depth discussion on the workings of each command. Lastly, the report summarizes some of the design challenges faced when building the software and concludes by discussing additional features that could be included in the design to improve its effectiveness and its usefulness.











2-) Monitor Program 

	"TUTOR 0" is a Monitor Program built using MC68000 assembly language. The program provides a command-line interface through which the user can perform a variety of functions capable of searching, displaying, modifying, moving and testing memory locations. The current version of this program includes 12 basic debugger commands that the user can enter at the terminal. Each of these commands are discussed extensively in this report, including their functionality, proper usage and design. Flowcharts and algorithms are provided for each command, followed by the assembly code designed to implement them. "TUTOR 0" (from here on, Monitor Program) also supports exception handling, and is able to deal with most of the common exceptions that can arise during regular operation. Descriptions of these, along with a discussion on the implementation of their exception-handling routines, are also provided in this report.


	Fig. Monitor 1

	On startup, the Monitor Program displays a welcome message and a terminal prompt. This is where the user can enter various commands and use them to accomplish their agenda. When a command is entered, the program first parses the input string to check what command is needed by the user. This is accomplished by a "Command Interpreter" (discussed in the next section), which then causes the program flow to branch of to the selected command. The program then further parsing the input string to acquire all the necessary arguments (data) required by the particular command. Finally, the specific command subroutine uses this data to implement the user-required operation, after which the program returns to the terminal, ready for the next user input. If the input string does not match any of the existing commamnds, or if one or more arguments required by the specific command subroutine is invalid, an error message is displayed and the program returns to the terminal without performing any operation. This is turn protects the contents of the registers and memory from being modified due to accidental or incorrect command inputs.


	Fig. Program Overview 

	At any point during the execution of a command, if any of the common exceptions arise (such as an address error when trying to access a word or long size data starting at an odd address), the Monitor Program branches off to the specific exception-handling subroutine. Based on the exception, the program outputs error messages along with additional information regarding the exception (discussed later). The program then returns to the terminal awaiting the next user input. Note, however, that the contents of registers and memory may have changed due to generated exception, since the program isn't capable of rolling back any changes made up to the point where the exception arises.
 
	The Monitor Program code (in memory) is divided up into four distinct spaces:
(1) The Monitor Program: This section comprises of code that displays the initial message, terminal prompt, and gets the user input. 
(2) The Command Interpreter: This block of codes contains subroutines that deal with parsing the input string, command interpretation, and acquiring data for the specific commands.
(3) The Command Space: Here, subroutines that perform the operation for each of the command is stored.
(4) The Exception Space: All exception handling routines are located here.

	Fig. Memory Space (Monitor 2)

	Each of these spaces are further divided up into "Data Space" -- where all of the memory data (such as prompts, error messages, reserved memory spaces) is stored -- and "Program Space" -- which contain the actual subroutines. Note that these definitions differ from their actual use in microprocessor architecture and are only used to segment the large code of the Monitor Program into manageable segments.

	Before discussing each of these sections is more detail, below is a list of certain program constraints and assumptions made (regarding the kinds and sizes of input data enterred as well as the commands on the whole) when implementation the code of the Monitor Program.


Constraints:
1) The entire Monitor program must lie within the address range 3K byte memory space.
2) A 1K byte size Stack is located at addresses $3000 and above.
3) The program must be able to handle erroneous inputs and recover from them.

Assumptions:
1) The inputted command string is no longer that 30 characters.
2) Hexadecimal input data are smaller than $FFFFFFF.
3) Decimal input data are smaller than 99999999.
4) Addresses entered do not line within $1000 and $3000.
5) At no point during normal execution does the Stack overflow (data on Stack exceeds 1K bytes).
	

Assembly Code for Monitor Program:

***************************
***   MONITOR  PROGRAM  ***
***************************
*-----------------------------------------------------------------------------------------------------------
*-------------------------------------------- DATA SPACE ---------------------------------------------------

* Stack Location
STACK EQU $3000

* Terminal Prompt 
TML DC.B 'TUTOR 0>'
TE  DC.B 0

* Input Buffer
INPUT DS.B 30 ; 30 characters max
      DC.B 0
      
* General Purpose Memory Registers (Also Serves As Extra Space In Case Input Is Too Long)
REG_X DC.L 0
REG_Y DC.L 0

* Welcome Message
WELC DC.B 'Welcome To TUTOR, Version 0!'
WE   DC.B  0  

* Thank you Message
THANK DC.B 'Thank You For Using TUTOR!'
TKE   DC.B  0 

*-----------------------------------------------------------------------------------------------------------
*-------------------------------------------- PROGRAM SPACE ------------------------------------------------
START:                  ; first instruction of program  

*** STARTS AT $1030

* Initialize Exception Vectors
    MOVE.L #STACK,$0
    MOVE.L #BUS_ERR,$8
    MOVE.L #ADRS_ERR,$C
    MOVE.L #ILL_INST,$10
    MOVE.L #DIV_ZERO,$14
    MOVE.L #CHK_INST,$18
    MOVE.L #PRIV_VIOL,$20
    MOVE.L #LINE_A,$28
    MOVE.L #LINE_F,$2C
  
* Set Stack Pointer to Top of Stack
    LEA STACK,A7
    
    JSR NEWLINE ; Print Blank Line
    
    JSR WELCOME ; Displays Welcome Message
        
    BRA RUN_MONITOR ; Start Monitor Program  
*-----------------------------------------------------------------------------------------------------------  
RUN_MONITOR
* Monitor Program Main Loop
*
    JSR TERMINAL ; Display Terminal Prompt & Get Input
    JSR CHK_CMD ; Check Entered Command & Branch to Appropriate Subroutine
    
    BRA RUN_MONITOR ; Loop till EXIT Command is Executed
*-----------------------------------------------------------------------------------------------------------
TERMINAL
* Displays Terminal Prompt and Gets User Input    
*
    MOVEM.L D0-D1/A1,-(A7) ; Save Registers to Stack 
    
    JSR NEWLINE ; Print Blank Line
    
* Print TUTOR Prompt
    LEA TML,A1
    MOVE.B #14,D0
    TRAP #15  
    
* Get Input String
    LEA INPUT,A1 ; Input (50 characters max)
    MOVE.B #2,D0
    TRAP #15
     
    MOVEM.L (A7)+,D0-D1/A1 ; Restore Registers from Stack  
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------   
NEWLINE
* Moves Print Cursor to the Next Line
*
    MOVEM.L D0/A1,-(A7) ; Store Registers on Stack
    
    LEA TE,A1 ; Address Starts with null character (To not Print Anything)
    MOVE.B #13,D0 ; Set TRAP Function to Output Null Terminated String Starting at A1
    TRAP #15  
    
    MOVEM.L (A7)+,D0/A1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
SPACE
* Displays a Blank Space
*
    MOVEM.L D0-D1,-(A7) ; Store Registers on Stack
    
    MOVE.B #$20,D1 ; D1.B = ' ' 
    MOVE.B #6,D0 ; Set TRAP Function to Output character in D1.B
    TRAP #15
    
    MOVEM.L (A7)+,D0-D1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
QUOTE
* Displays a Double Quote (")
*
    MOVEM.L D0-D1,-(A7) ; Store Registers on Stack
    
    MOVE.B #$22,D1 ; D1.B = Double Quote
    MOVE.B #6,D0 ; Set TRAP Function to Output character in D1.B
    TRAP #15
    
    MOVEM.L (A7)+,D0-D1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
WELCOME
* Displays Welcome Message
*
    MOVEM.L D0/A1,-(A7) ; Store Registers on Stack
    
* Print Welcome Message
    LEA WELC,A1
    MOVE.B #13,D0
    TRAP #15  
    
    MOVEM.L (A7)+,D0/A1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
THANKYOU
* Displays ThankYou Message
*
    MOVEM.L D0/A1,-(A7) ; Store Registers on Stack
    
* Print ThankYou Message
    LEA THANK,A1
    MOVE.B #14,D0
    TRAP #15  
    
    MOVEM.L (A7)+,D0/A1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*----------------------------------------------------------------------------------------------------------- 
*-----------------------------------------------------------------------------------------------------------



2.1-)  Command Interpreter 

To execute a command, the user must first enter the command at the terminal. Next, the program must to recognize the entered command and branch to appropriate subroutine to perform its required function. The "Command Interpreter" is a special subsection of the program which facilitates this operation. It checks the user input and determines if the entered string is a valid command. If not, an error message is displayed and the program returns to the terminal, ready for the next user input.
Apart from the command name, the user inputted string may contain additional data that may be used in the operation of the command. These may be addresses, immediate data or strings. Among these, the addresses and immediate may either be hexadecimal (represented by the '$' symbol) or decimal (no '$' symbol). Therefore, the "Command Interpretter" must possess the capability to read and decipher this data, and then provide it to the appropriate subroutines that require them. As far as the scope of this program is concerned, any inputted command must follow a syntax, which is discussed in the following section.

2.1.1-) Syntax

General Syntax: <Space> <Command Name>  <Data> <Mode> <CR>

A valid command must begin with a "Space" character. This is true for all commands except for the memory-modify loop in the "MM" (Memory Modify) command, which is discussed later on. The "space" character is followed by the "Command Name" which must be entered in uppercase letters. Following this, there may be 0, 1, 2 or 3 data which need to be separated by "Space" characters. The data can either be a decimal number (for eg. "2500") or a hexadecimal number which must have a leading '$' sign (for eg. "$1A00"). The numbers using symbols A-F must also be written in uppercase letters. Once all the required data has been entered, the command must end with a carriage return <CR> and must not have any trailing "Space" or other characters. Following are examples of valid commands containing different types of data:

No Data : "TUTOR 0.1> EXIT<CR>"
One Datum : "TUTOR 0.1> GO $9000<CR>"
Two Data : "TUTOR 0.1> MS 7000 'Hello World!'<CR>"
Three Data : "TUTOR 0.1> BF $4000 $5000 865<CR>"

For some commands, users have the freedom to specify a "Mode" of operation. This is entered by using the semicolon (";") character followed by an uppercase letter specifying the "Mode". Note, however, that the semicolon character must be enterred immediately after the last data, without leaving a blank space in between. The most appropriate example would be the "MM" (Memory Modify) command which has three available modes: B (Byte Operation), W (Word Operation) and L (Long Operation). Following is an example of the use of such a syntax:

"TUTOR 0.1> MM $8000;L<CR>"

If the command above is enterred at the terminal, the Monitor program will execute the Memory Modify Operation using Long Word Size Addresses.


2.1.3-) Overall Design and Components

***Terminal Pic***

When the Monitor Program is first run, it will display a prompt where the user can enter commands. The user must enter an appropriate command followed by a carriage return to begin processing of the input. These commands are comprised of a "Command Name", "Data" and "Mode". To manage all these kinds of inputs, the "Command Interpretter" has three separate subroutines, each of which controls a certain type of input. Each of these subroutines are discussed extensively in the following sections.










"CHK_CMD" (Check Command Name) : This subroutine checks the "Command Name" of the entered command. If it is a valid command, this subroutine calls the appropriate subroutine(s) to perform the required operation. Else, an error message is displayed.

"GET_DATA" (Get Single Datum) : This subroutine gets a single hexadecimal or decimal datum from the user input string, which can then be used by the subroutines designed to implement the debugger commands. If the data is invalid, an error message is displayed.

"GET_MODE" (Get Single Datum) : This subroutine determines the mode of operation for certain debugger commands. If the input is invalid, an error message is displayed.


Apart from these three major subroutines, there are a few other auxillary subroutines that assist their operation. As these subroutines are short and since their main purpose is to support the three major subroutines, only a short description of their functionality is sufficient.

"CHK_END" (Check End) : This subroutine checks whether the inputted command has been properly ended with a carriage return. If not, an error message is displayed.

"INVALID" : This subroutine displays the message "INVALID COMMAND!" to the screen.

"HEX_DEC" (Hex to Decimal) : This subroutine converts a hexadecimal number in D1 to its corresponding decimal value.





2.1.4-) CHK_CMD Subroutine

After the user has inputted a command, this is the first subroutine that is called by the program. Here, the "Command Name" is read from the user input and is compared with the list of command names in the "CMD_N" table in memory. If a match is found, the subroutine performs basic calculations to find the corresponding address for the command subroutine from the "CMD_A" (Command Addresses) table in memory. Next, this subroutine uses a JMP (Jump) instruction to pass on control of the program flow to the appropriate command subroutine. If no match was found in the command names table, an error message is displayed and the program control returns to the terminal.



Algorithm:

Step 1: Save registers to Stack
Step 2: Initialize A0 -> start address of "Command Names" table 
Step 3: Initialize A1 -> end address of "Command Names" table 
Step 4: Initialize A2 -> start address of input string
Step 5: IF character at (A2) = '  '  // Check for leading space character
	THEN go to Step 7
	ELSE go to Step 23 // Command Invalid
Step 6: Initialize A2 -> start address of input string
Step 7: IF A2 > A1  // If command name not found in entire address range
	THEN go to Step 8
	ELSE go to Step 23 // Command Invalid
Step 8: IF character at (A2) = '  '  OR character at (A2) = null // If input command name has ended
	THEN go to Step 23 // Command Invalid
	ELSE go to Step 9
Step 9: IF character at (A2) = character at (A0) // If character matched
	THEN go to Step 12
	ELSE go to Step 10
Step 10: A0 = A0 + 1 // Check next character from table
Step 11: Go to Step 8
Step 12: A0 = A0 + 1 // Check next character from table
Step 13: A2 = A2 + 1 // Check next character from input
Step 14: IF A2 > A1 // If command name not found in entire address range
	THEN go to Step 15
	ELSE go to Step 23 // Command Invalid
Step 15: IF character at (A0) = '  ' // If command name in table has ended
	THEN go to Step 17 // Character found
	ELSE go to Step 16
Step 16: IF character at (A2) = character at (A0) 
	THEN go to Step 12
	ELSE go to Step 10
Step 17: Offset = [A0-Start Address of "Command Names" table]/ 6 * 2
Step 18: A1 = Start Address of "Command Addresses" table + Offset
Step 19: Get (A1) in A0 // Load address to jump
Step 20: Jump to address in A0
Step 21: Restore registers from Stack
Step 22: Return from subroutine
Step 23: Display error Message
Step 24: Restore registers from Stack
Step 25: Return from subroutine

Figure 2.2. Command Interpreter Algorithm  



Flowchart:

Figure 2.3.  Command Interpreter Flowchart  




2.1.5-) GET_DATA Subroutine

Along with the "Command Name", the user input string may contain one or more data. Therefore, there needs to be a way to parse these data from the input string and provide it to the subroutines that may require it.The GET_DATA subroutine accomplishes this task. It extracts the data from the input string and interprets its hexadecimal or decimal value (based on the presence/absence of the '$' symbol). It then stores this data in the memory location whose address is specified by the A0 register. For this Monitor program, three long word size memory locations have been reserved to store this data. The data must always start with a space character and end with either a space character, semicolon or a carriage return. If the data is invalid, an error message is displayed.



Algorithm:

Step 1: Save registers to Stack
Step 2: Clear result register D1  // Initial result = 0
Step 3: Initialize A1 -> current position of instruction pointer
Step 4: IF character at (A1) = '  '    // Check for leading space
	THEN go to Step 5
	ELSE go to Step 21  // Data Invalid
Step 5: IF character at (A1) = ' $'   // Check if data is hex
	THEN clear flag D2
	ELSE set flag D2
Step 6: IF character at (A2) = '  '  OR character at (A2) = null OR character at (A2) = ';'  // Check if data has ended
	THEN go to Step 7    // More data to acquire
	ELSE go to Step 16  // Data acquired
Step 7: IF $30 <= character ASCII value <= $39 // Check if data is 0-9
	THEN go to Step 8
	ELSE go to Step 10  
Step 8: Subtract $30 from character ASCII value in D0 ; Get decimal value
Step 9: Go to Step 12
Step 10: IF $40 < character ASCII value < $47  // Check if data is $A-$F
	THEN go to Step 11
	ELSE go to Step 21  // Data Invalid
Step 11: Subtract $55 from character ASCII value in D0 // Get decimal value
Step 12: Muliplily result register by 16
Step 13: Add D0 to result register D1
Step 14: A1 = A1 + 1 // Get next character
Step 15: Go to Step 6 
Step 16: IF flag D2 is set  // Check if further conversion is needed
	THEN go to Step 17 // Yes
	ELSE go to Step 18  // No
Step 17: Convert to decimal number (call subroutine)
Step 18: Store result in (A0), i.e. in memory
Step 19: Restore registers from Stack
Step 20: Return from subroutine
Step 21: Display error Message
Step 22: Restore registers from Stack
Step 23: Return from subroutine

Figure 2.2. Command Interpreter Algorithm  



Flowchart:

Figure 2.3.  Command Interpreter Flowchart  





2.1.6-) GET_MODE Subroutine

Some debugger commands allow the user to decide the mode of operation. This is represented by a semicolon symbol (";") followed by a single character, which decides the mode of operation. In this Monitor program, two debugger commands support mode -- "MM" (Memory Modify) supports 'B' (byte operation), 'W' (word operation) and 'L' (long word operation), and "SORTW' (Sort Word) supports 'A' (ascending order) and 'D' (descending order). Therefore, there needs to be a way to parse this "Mode" from the input string. The "GET_MODE" subroutine performs this task. The mode must be entered right after the last data, without leaving a space. This subroutine stores the acquired "Mode" in the memory location specified by A0. For this Monitor program, three long word size memory locations have been reserved to store this data. Lastly, if the data is invalid, an error message is displayed.



Algorithm:

Step 1: Save registers to Stack
Step 2: Initialize A2 -> start address of input string
Step 3: IF character at (A2) = ';'    // Check for leading semicolon
	THEN go to Step 4
	ELSE go to Step 9  // Data Invalid
Step 4: A2 = A2 + 1  // Go to next character
Step 5: Get character from (A2) in D0
Step 6: Store D0 in (A0), i.e. in memory
Step 7: Restore registers from Stack
Step 8: Return from subroutine
Step 9: Display error Message
Step 10: Restore registers from Stack
Step 11: Return from subroutine

Figure 2.2. Command Interpreter Algorithm  



Flowchart:

Figure 2.3.  Command Interpreter Flowchart  


2.1.7-) Command Interpreter Assembly Code 

***************************
*** COMMAND INTERPRETER ***
***************************
*-----------------------------------------------------------------------------------------------------------
*-------------------------------------------- DATA SPACE ---------------------------------------------------

*Input Pointer to Read Input String Saved in Memory
INP_PTR DC.L 0 

* Memory Spaces to Store Parsed Data from Input String
DATA1 DC.L 0
DATA2 DC.L 0
DATA3 DC.L 0 

* Error Message for Invalid Input
ERRC DC.B 'INVALID COMMAND!'
CE   DC.B 0

* Table of Command Names
CMD_N DC.B 'HELP  '
      DC.B 'MDSP  '
      DC.B 'SORTW '
      DC.B 'MM    '
      DC.B 'MS    '
      DC.B 'BF    '
      DC.B 'BMOV  '
      DC.B 'BTST  '
      DC.B 'BSCH  '
      DC.B 'GO    '
      DC.B 'DF    '
      DC.B 'EXIT  '
      DC.B 'UPPER '
      DC.B 'BREV  '
      
* Table of Command Addresses
CMD_A DC.W HELP
      DC.W MDSP
      DC.W SORTW
      DC.W MM
      DC.W MS
      DC.W BF
      DC.W BMOV
      DC.W BTST
      DC.W BSCH
      DC.W GO
      DC.W DF
      DC.W EXIT
      DC.W UPPER
      DC.W BREV
      
*-----------------------------------------------------------------------------------------------------------
*-------------------------------------------- PROGRAM SPACE ------------------------------------------------
CHK_CMD   
* Looks for Entered Command in CMD_N and Calls the Command Subroutine if found
* If Command is not found, Error Message is Displayed  
  
    MOVEM.L D0-D1/A1-A3,-(A7) ; Save Registers to Stack
    MOVE.L A0,$102A  ; Save A0 in memory
    
    LEA CMD_N,A0 ; Start Address of Command Names
    LEA CMD_A,A1 ; Start Address of Command Subroutines
    LEA INPUT,A2 ; Start Address of Input
    LEA INP_PTR,A3 ; Address of Input Pointer
    
* Check for starting space character  
    MOVE.B (A2)+,D1
    CMP.B #$20,D1
    BNE CHK_INV ; If no, then Command is Invalid
    
    MOVE.L A2,(A3) ; Save Start Address of Input Command in INP_PTR
    
* Find Match for First Character
MATCH1 MOVE.L (A3),A2 ; Get Start Address of Input Command in A2
    MOVE.L A0,D0 ; Save Start Address of Matched First Character in D0
    
    CMP.L A0,A1 ; A1 - A0
    BEQ CHK_INV ; If reached end of CMD_T, Command Not Found
    
    MOVE.B (A0)+,D1 ; Get a character from CMD_T to D1 
    CMP.B (A2)+,D1 ; D1 - (A2)
    BNE MATCH1 ; If character doesn't match Input Command character, keep searching
    
* Current State: First character of Command Input Matched
    
MATCH2 MOVE.B (A0)+,D1 ; Get a character from CMD_T to D1

    CMP.B #$20,D1 ; Check if character = ' '
    BEQ AT_END ; If true, then reached end of Command Name
    
    CMP.B (A2)+,D1 ; D1 - (A2)
    BNE MATCH1 ; If character doesn't match Input Command character, search for first character again
    
    CMP.L A0,A1 ; A1 - A0
    BGT MATCH2 ; If not reached end of CMD_T, Command Name matches so far
    BRA CHK_INV ; If reached end of CMD_T, Command Not Found
    
AT_END
    CMP.B #0,(A2) ; Check if next character in Input Command is null
    BEQ FOUND ; If yes, Command Found
    CMP.B #$20,(A2) ; Check if next character in Input Command = ' '
    BNE MATCH1 ; If no, search for first character again
    
FOUND
    MOVE.L A2,(A3) ; Save Current Location of Pointer in INP_PTR
    
* Get Address of Command Subroutine    
    LEA CMD_N,A0 ; Start Address of Command Names
    SUB.L A0,D0 ; Find Offset From Start of Command Names Table
* Offset of Command Address from Start of Command Address Table = (Offset from Start of Command Names Table) / 6 * 2
    DIVU #6,D0 ; Offset/6
    MULU #2,D0 ; Offset*2
    ADD.L A1,D0 ; Get Address in Command Address Table  
    MOVE.L D0,A1 ; Set Pointer to that Address
    MOVE.W (A1),A0 ; Get Command Subroutine Start Address in A0
    
    MOVEM.L (A7)+,D0-D1/A1-A3 ; Restore Registers from Stack
    ADD.L #4,A7 ; Throw a Long Word off of Stack
    
    JSR (A0) ; Jump to Command Subroutine
    BRA RUN_MONITOR ; Return from Subroutine
    
CHK_INV JSR INVALID ; Display Error Message    
    
    MOVEM.L (A7)+,D0-D1/A1-A3 ; Restore Registers from Stack
    MOVE.L $102A,A0 ; Restore A0 from Memory
    
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
GET_DATA 
* Parses Data from Input String and Stores it in memory
* Input: Start Address to store result in A0
* D6 = 1 for invalid input

    MOVEM.L D0-D2/A0-A2,-(A7) ; Save Registers to Stack
    
    CLR.L D1 ; Clear Register to Calculate Hex Data
    CLR.L D2 ; Clear Flag (for Hex Operation)
    
    LEA INP_PTR,A1 ; Get Address of Stored Pointer Location
    MOVE.L (A1),A2 ; Get Current Input Pointer Address in A2
    
* Check for starting space character  
    MOVE.B (A2)+,D0
    CMP.B #$20,D0
    BNE GD_INV ; If no, then Data is Invalid
    
    CMP.B #$24,(A2) ; Check if first character = '$' 
    BNE NOTHEX ; If not, proceed assuming the data is decimal
    
    MOVE.L #1,D2 ; If yes, Set Flag (for Hex Operation)
    ADD.L #1,A2 ; Move pointer to the character after '$'
   
* Check if first character is ';'
NOTHEX CMP.B #$3B,(A2) ; Check if next character is ';' 
    BEQ GD_INV ; If yes, then Command is Invalid
    
* Check if character is a number    
ISNUM CMP.B #$3B,(A2) ; Check if next character is ';' 
    BEQ EOD ; If yes, then reached end of data
    CLR.L D0 ; Clear D0
    MOVE.B (A2)+,D0 ; Get a character in D0
    DIVU #$10,D0 ; D0/10
    CMP.W #3,D0 ; Check if 30 <= ASCII character value <= 39
    BEQ HEX ; If character is a number, proceed to conversion

    CMP.L #1,D2 ; Check if number is supposed to be Hex
    BNE GD_INV ; If not, then Number is Invalid
    
* Check if character is a Hex digit
    CMP.W #4,D0 ; Check if character could be between A-F
    BNE GD_INV ; If no, then number is Invalid
    SWAP D0 ; Get remainder in lower word
    CMP.W #0,D0 ; Check if character could be '@'
    BEQ GD_INV ; If yes, then number is Invalid
    CMP.W #6,D0 ; Check if D0 - 6 > 0
    BGT GD_INV ; If yes, then number is Invalid
    
* Number is a valid Hex digit: Remainder is between 1 to 6
    ADD.W #9,D0 ; Remainder becomes 10 to 15 (i.e A to F)
    SWAP D0 ; Put remainder in the upper word   

* Convert the ASCII Data to Hex (Assuming Input Data is Hex)    
HEX LSL.L #4,D1 ; D1*16
    SWAP D0 ; Get remainder in lower word
    ADD.W D0,D1 ; Add remainder to D1
    
    CMP.B #0,(A2) ; Check if next character is ' ' 
    BEQ EOD ; If yes, then reached end of data
    CMP.B #$20,(A2) ; Check if next character is null
    BEQ EOD ; If yes, then reached end of data
    BRA ISNUM ; If no, continue conversion
    
EOD    
    CMP.B #1,D2 ; Check if Flag is Set
    BEQ COMPLETE ; If yes, then operation complete
    JSR HEX_DEC ; If yes, then get the Decimal Equivalent for the Hex number
    
COMPLETE MOVE.L D1,(A0) ; Store Data in (A0)
    MOVE.L A2,(A1) ; Store Current Input Pointer Location
    
    MOVEM.L (A7)+,D0-D2/A0-A2 ; Restore Registers from Stack
    RTS ; Return from Subroutine
    
GD_INV MOVE.B #1,D6 ; Denote Error Message
    MOVEM.L (A7)+,D0-D2/A0-A2 ; Restore Registers from Stack
    RTS ; Return from Subroutine

*-----------------------------------------------------------------------------------------------------------
GET_MODE
* Parses Mode from Input String and Stores it in Memory
* Input: Start Address to store result in A0

    MOVEM.L D0/A0-A2,-(A7) ; Save Registers to Stack
    
    LEA INP_PTR,A1 ; Get Address of Stored Pointer Location
    MOVE.L (A1),A2 ; Get Current Input Pointer Address in A2
    
* Check for ';' Character
    CMP.B #$3B,(A2)+ ; Check if Character is ';'
    BNE INVALID ; If no, then Command is Invalid
    
    CLR.L D0 ; Clear Temporary Register D0
    MOVE.B (A2)+,D0 ; Get Mode ASCII Character in D0
    MOVE.L D0,(A0) ; Store Mode in (A0)
    MOVE.L A2,(A1) ; Store Current Input Pointer Address in INP_PTR
    
    MOVEM.L (A7)+,D0/A0-A2 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
CHK_END
* Checks for <CR> at the End of Command
* Output: D6 = 1 for Invalid Command / D6 = 0 for Valid Command

    MOVEM.L D0/A3-A4,-(A7) ; Store Registers on Stack
    
    LEA INP_PTR,A4 ; Get Address of Input Pointer Location in A4
    MOVE.L (A4),A3 ; Get Current Location of Input Pointer in A3
    MOVE.B (A3),D0 ; Get Character at Current Pointer Location in D0
    BEQ CE_V ; If null, then Command is valid
    
    MOVE.L #1,D6 ; D6 = 1 for Invalid Command
    BRA CK_END ; Operation Complete
    
CE_V CLR.L D6 ; D6 = 0 for Invalid Command

CK_END MOVEM.L (A7)+,D0/A3-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
INVALID 
* Displays Invalid Message
*
    MOVEM.L D0/A1,-(A7) ; Save Registers to Stack
    
* Print "INVALID COMMAND!"
    LEA ERRC,A1
    MOVE.B #13,D0
    TRAP #15
    
    MOVEM.L (A7)+,D0/A1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------  
HEX_DEC
* Convert Hex Number in D1 to Decimal 
* Used in GET_DATA Subroutine
    MOVEM.L D2-D6,-(A7) ; Save Registers to Stack
    
    CLR.L D5 ; Clear Register to Store Result
    MOVE.L #1,D2 ; Set Starting Multiplier to 1
    
CONV CLR.L D4 ; Clear Temporary Register
    MOVE.L D1,D6 ; Make a Copy of D1 in D6
    ANDI.L #$F,D6 ; D6 = D1%16 (Remainder)
    ADD.L D2,D4 ; Add Multiplier to Temporary Register
    MULU D6,D4 ; Multiply Temporary Register by Remainder
    ADD.L D4,D5 ; Add Product to Result Register
    MULU #10,D2 ; Multiplier = (Multiplier)*16
    LSR.L #4,D1 ; D1 = D1/16 (Quotient)
    BNE CONV ; If Input != 0, continue conversion
    MOVE.L D5,D1 ; If Input = 0, Store Result in D1
     
    MOVEM.L (A7)+,D2-D6 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------
*-----------------------------------------------------------------------------------------------------------


Figure 2.4. 68000 Assembly Code   



2.2-) Debugger Commands

The current version of the Monitor program contains 12 basic debugger commands that the user can enter at the terminal. These commands can be used to carry out a wide range of operations including searching, displaying, modifying, moving and testing memory locations. Each command has its own subroutine that performs its operation and, based on the "Command Name" inputted, the "Command Interpreter" calls the appropriate subroutine. Also, depending on its operation, different functions require different sets of input data. In the following sections, each debugger command is discussed in detail, looking into their functionality, required inputs, constraints and so on. This is aided by flowcharts and algorithms, followed by the assembly code designed to implement the particular command. Following is a list of all existing commands:

HELP
EXIT
DF
GO
MS
BF
BMOV
BTST
BSCH
MDSP
MM
SORTW


2.2.1-) HELP

Function: A user new to the Monitor Program may not know the existing commands supported. Even if they do, they might have issues remember their syntax. Rather than having the user read a large instruction manual, it is easier to have a command that summarizes the basic operatin and syntax of all commands in a few words. The " HELP" command acomplishes this. Users can just enter "HELP" at the terminal and a description of all 12 existing commands and their usage will be displayed on screen.

Syntax: "TUTOR 0.1> HELP<CR>"


How It Works: A string containing the HELP lookup table is stored in memory. Each line that needs to be displayed is separated using a null character. The entire string is then terminated by three consecutive null characters. The "HELP" subroutine displays the string character by character. When a null character is located, the subroutine outputs a carriage return (<CR>). This goes on till three consecutive null characters are located, after which the program returns to terminal. If the command is not entered correctly, an error message is displayed, and the program returns to the terminal. 



2.2.1.1-) HELP Algorithm

Step 1: Save registers to Stack
Step 2: Initialize A2 -> start address of input string
Step 3: IF character at (A2) = null   // Check for carriage return
	THEN go to Step 4
	ELSE go to Step 16  // Data Invalid
Step 4: Initialize A1 -> start addres of HELP lookup table
Step 5: Counter = 0 // To count consecutive null characters
Step 6: IF character at (A1) = null   // Check for a null character
	THEN go to Step 7
	ELSE go to Step 13
Step 7: Display a new line // To display next characters on new line
Step 8: Counter = Counter + 1  // Increment counter
Step 9: IF counter = 3 // Three consecutive null characters
	THEN go to Step 14  // Done displaying string
	ELSE go to Step 12
Step 10: Display character
Step 11: Counter = 0 // Null characters must be consecutive
Step 12: A1 = A1 + 1  // Go to next character
Step 13: Go to Step 6 // Display all characters in the string
Step 14: Restore registers
Step 15: Return from subroutine
Step 16: Display error message
Step 17: Go to Step 14

2.2.1.2-) HELP Flowchart












Figure 2.6.  Debugger Command # 1 Flowchart  

2.2.1.3-) HELP Assembly Code 

*-------------------------------------------------------------------------------------------- 
HELP
* Displays HELP Lookup Table
*
    MOVE.L $102A,A0 ; Restore A0 from Memory
    MOVEM.L D0-D2/D6/A1,-(A7) ; Store Registers on Stack
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 0
    BEQ H_INV ; If yes, then Command is Invalid
    
    MOVE.B #6,D0 ; Set TRAP Function to Output Character
    CLR.B D2 ; Counter for Number of Null Characters
    
    LEA INFO,A1 ; Load Start Address of HELP Lookup Table in A1
    
H_LOOP MOVE.B (A1)+,D1 ; Get Character in D1
    
    CMP.B #3,D2 ; Look for 3 consecutive null characters
    BEQ H_DONE ; If yes, then Done
    
H_N1 CMP.B #0,D1 ; Check if character is null
    BNE H_N2 ; If no, then don't increment counter
    
    JSR NEWLINE ; Move to Next Line
    
    ADD.B #1,D2 ; Increment Null Counter
    BRA H_N3 ; Jump
    
H_N2 CLR.B D2 ; Reset Null Counter

H_N3 TRAP #15 ; Display Character to Terminal
    BRA H_LOOP ; Loop till 3 consecutive null characters are found

H_DONE MOVEM.L (A7)+,D0-D2/D6/A1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
    
H_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0-D2/D6/A1 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------------------

2.2.2-) EXIT

Function: The "EXIT" command is used to exit from the terminal so that no further operation can be performed. If the command is entered incorrectly, an error message is displaye and the program returns to the terminal.

Syntax: "TUTOR 0.1> EXIT<CR>"


How It Works: To exit from the Monitor program the TRAP #15 Task 9 is used. This TRAP function halts the simulator, thus causing the program to stop executing.


2.2.2.1-) EXIT Algorithm

Step 1: Save registers to Stack
Step 2: Initialize A2 -> start address of input string
Step 3: IF character at (A2) = null   // Check for carriage return
	THEN go to Step 4
	ELSE go to Step 5  // Data Invalid
Step 4: Execute Sim Halt TRAP // Exit the program
Step 5: Display error message
Step 6: Restore registers from Stack
Step 7: Return from subroutine



2.2.2.2-) EXIT Flowchart



2.2.2.3-) EXIT Assembly Code 

*--------------------------------------------------------------------------------------------------------------------------    
EXIT
* Exits the Monitor Program
*
    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVE.L D6,-(A7) ; Save Register to Stack
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.L #1,D6 ; Check if D6 = 0
    BEQ NO_EXIT ; If yes, then Command Invalid

* Exit Monitor Program
    MOVE.B #9,D0 ; Set TRAP Function to HALT Simulator
    TRAP #15
    
NO_EXIT JSR INVALID ; Display Error Message
    MOVE.L (A7)+,D6 ; Restore Register from Stack
    RTS ; Return from Subroutine

*--------------------------------------------------------------------------------------------------------------------------




2.2.3-) DF

Function: The "DF" command is used to display the contents of all registers -- PC, SR,US,SS, Data Registers and Address Registers -- at the time this command is executed. It should be noted that the values displayed by this command are the ones that the registers possessed before this function was called, and any changes made to the registers during the execution of this command do not reflect back on the register data on screen. If the command is entered incorrectly, an error message is displayed, and the program returns to the terminal.

Syntax: "TUTOR 0.1> DF<CR>"

How It Works: When this command is executed the value of PC is obtained from the top of the Stack (PC is stored on Stack by JSR instruction) and is stored in memory. Similarly, the value of Supervisor Status Register (SS) is also saved in memory (Here SR = A7 since the code is running in Supervisor Mode). When displaying these registers, their values are read from their respective memory locations and they are then outputted to the screen.
Values of Supervisor Status Word (SR) and User Stack Pointer (US) are obtained using the "MOVE from SR" and the "Move from USP" instrucutions respectively.
 All Data Registers and Address Registers are then stored on the Stack twice -- once to display and once again to restore values of registers. 



2.2.3.1-) DF Algorithm

Step 1: IF character at (A2) = null   // Check for carriage return
	THEN go to Step 2
	ELSE go to Step 16  // Data Invalid 
Step 2: Get PC from the top of Stack and store in memory // PC stored on Stack by JSR instruction 
Step 3: Save SS in memory // SS = A7 in Supervisor Mode
Step 4: Save registers to Stack // To restore values at the end of subroutine
Step 6: Save registers to Stack // To display values one by one
Step 7: Read PC from memory and display on screen // Read from where it was stored
Step 8: Read US and display on screen // Use MOVE from USP
Step 9: Read SR and display on screen // Use MOVE from SR
Step 10: Read SS from memory and display on screen // Read from where it was stored
Step 11: Read register value from Stack and display on screen // D0-D7 & A0-A6
Step 12: IF D0-D7 & A0-A6 all displayed
	  THEN go to Step 13
              ELSE go to Step 11
Step 13: Read A7 and display on screen // A7 was not stored on Stack using MOVEM.L intstruction
Step 14: Restore registers from Stack
Step 15: Return from Subroutine
Step 16: Display error message
Step 17: Return from subroutine

2.2.3.2-) DF Flowchart



2.2.3.3-) DF Assembly Code 


*--------------------------------------------------------------------------------------------------------------------------
DF 
* Displays Current Values PC, SR, US, SS, Data Registers and Address Registers
*
    MOVE.L $1030,A0 ; Restore A0 from Memory
    
    MOVE.L D6,-(A7) ; Save D6 on Stack
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.L #1,D6 ; Check if D6 = 0
    BEQ NO_DF ; If yes, then command is invalid
    
    MOVE.L (A7)+,D6 ; Restore D6 from Stack
    MOVE.L A0,-(A7) ; Save A0 on the Stack
    
* Save Value of PC in memory (REG_X)
    LEA REG_X,A0 ; Get Address of REG_X in A0
    ADD.L #4,A7 ; Get to PC Location
    MOVE.L (A7),(A0) ; Save Value
    SUB.L #4,A7 ; Return to Otiginal Location
    
* Save Value of SS (equal to A7) in memory
    LEA REG_Y,A0 ; Get Address of REG_Y in A0
    MOVE.L A7,(A0) ; Save SS/A7 in REG_Y (Memory)
    ADD.L #8,(A0) ; Get Actual Value of SS/A7 in REG_X
    
    MOVE.L (A7)+,A0 ; Restore A0 from the Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
* Display PC
    MOVE.B #$50,D1 ; Output Character 'P' 
    MOVE.B #6,D0
    TRAP #15
    
    MOVE.B #$43,D1 ; Output Character 'C' 
    TRAP #15
    
    MOVE.B #$3D,D1 ; Output Character '=' 
    TRAP #15
    
    LEA REG_X,A0 ; Get Address of REG_X in A0
    MOVE.L (A0),D2 ; Get PC in D2
    MOVE.L #4,D3 ; Set Number of Bytes to Display = 4
    JSR DISPREG
    
    JSR SPACE ; Leave a Blank Space
    
* Display SR
    MOVE.B #$53,D1 ; Output Character 'S' 
    MOVE.B #6,D0
    TRAP #15
    
    MOVE.B #$52,D1 ; Output Character 'R' 
    TRAP #15
    
    MOVE.B #$3D,D1 ; Output Character '=' 
    TRAP #15

    MOVE SR,D2 ; Get SR in D2
    MOVE.L #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG
    
    JSR SPACE ; Leave a Blank Space
     
* Display US
    MOVE.B #$55,D1 ; Output Character 'U' 
    MOVE.B #6,D0
    TRAP #15
    
    MOVE.B #$53,D1 ; Output Character 'S' 
    TRAP #15
    
    MOVE.B #$3D,D1 ; Output Character '=' 
    TRAP #15

    MOVE USP,A1 ; Get US in A1
    MOVE.L A1,D2 ; Get US in D2
    MOVE.L #4,D3 ; Set Number of Bytes to Display = 4
    JSR DISPREG
    
    JSR SPACE ; Leave a Blank Space
    
* Display SS
    MOVE.B #$53,D1 ; Output Character 'S' 
    MOVE.B #6,D0
    TRAP #15
    
    MOVE.B #$53,D1 ; Output Character 'S' 
    TRAP #15
    
    MOVE.B #$3D,D1 ; Output Character '=' 
    TRAP #15

    LEA REG_Y,A0 ; Get Address of REG_Y in A0
    MOVE.L (A0),D2 ; Get SS from Memory
    JSR DISPREG

DISP_DA
    MOVE.B #0,D5 ; Counter: 0 = D, 1 = A, >1 = Operation Complete

DA_START JSR NEWLINE ; Go to Next Line
    MOVE.B #$30,D4 ; Counter for Register Number    
    
RLOOP CMP.B #1,D5 ; Check if Couter is 1
    BEQ A_REG ; If yes, then Register to be Displayed is an Adress Register
    
    MOVE.B #$44,D1 ; Output Character 'D' 
    BRA D_REG ; Register to be Displayed is a Data Register
    
A_REG MOVE.B #$41,D1 ; Output Character 'A'

D_REG TRAP #15

    MOVE.B D4,D1 ; Output Register Number 
    TRAP #15
    
    MOVE.B #$3D,D1 ; Output Character '=' 
    TRAP #15
    
    TST.B D5 ; Check if Data Registers are Being Displayed
    BEQ CONTINUE ; If yes, then Continue
    
    CMP.B #$37,D4 ; Check if A7 is to be Displayed
    BEQ DF_DONE ; If yes, then Exit Display Registers Loop
    
CONTINUE MOVE.L (A7)+,D2 ; Get Register Value from Stack
    JSR DISPREG
    
    JSR SPACE ; Leave a Blank Space
    
    ADD.B #1,D4 ; Increment Register Number
    
    CMP.B #$34,D4 ; Check if Register Number < 4
    BLT RLOOP ; Loop for Registers D0-D3 & A0-A3
    
    CMP.B #$34,D4 ; Check if Register Number != 4
    BNE SAME_LINE ; If no, then Display Next Register on the Same Line
    JSR NEWLINE ; If yes, then Display Next Register on the Next Line
    
SAME_LINE CMP.B #$38,D4 ; Check if Register Number < 8
    BLT RLOOP ; Loop for Registers D4-D7
 
    ADD.B #1,D5 ; Increment Counter
    BRA DA_START ; Continue Displaying Registers till A7
    
DF_DONE MOVE.L (A0),D2 ; Get A7 from Memory
    JSR DISPREG ; Display A7
    
    JSR NEWLINE ; Leave a Blank Line
    
    MOVEM.L (A7)+,D0-D7/A0-A6 ; Restore All Registers from Stack
    RTS ; Return from Subroutine
    
NO_DF JSR INVALID ; Display Error Message
    MOVE.L (A7)+,D6 ; Restore D6 from Stack
    RTS ; Return from Subroutine

*---------------------------------------------------------------------------------------------------------------



2.2.4-) GO

Function: The "GO" command is used execute a piece of code stored in memory. This command takes one input -- the address to start executing code at. This address can be given as a hexadecimal number (represented by the '$' symbol) or a decimal number (no '$' symbol). If the command is entered incorrectly, an error message is displayed and the program returns to the terminal.

Syntax: "TUTOR 0.1> GO $2000<CR>"
		OR
	"TUTOR 0.1> GO 8192<CR>"
In both of the above examples, the program will start executing code starting at the same address since $2000 (hexadecimal value) = 8192 (decimal value). Thus, both types of input are accepted by the subroutine.


How It Works: To execute the "GO" command, the subroutine needs to know the address at which to start executing code. Since this is provided in the user input, the "GET_DATA" subroutine (discussed in the previous section) is used. This address is then put into an address register, and the program jumps to the aforementioned memory location. 


2.2.4.1-) GO Algorithm

Step 1: Save registers to Stack
Step 2: Get address to jump to in A6 // Calls subroutine "GET_DATA"
Step 3: IF character at (A2) = null   // Check for carriage return
	THEN go to Step 4
	ELSE go to Step 6  // Data Invalid
Step 4: Restore registers from Stack
Step 5: Jump to (A6)
Step 6: Display error message
Step 7: Restore registers from Stack
Step 8: Return from subroutine

2.2.4.2-) GO Flowchart



2.2.4.3-) GO Assembly Code 

*-------------------------------------------------------------------------------------------------------------------------
GO
* Executes Code in Memory Starting at the Inputted Address
*
    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D6/A0/A6,-(A7) ; Save Registers to Stack
    
* Get Address in A6
    LEA DATA1,A0
    JSR GET_DATA
    MOVE.L (A0),A6
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.L #1,D6 ; Check if D6 = 1
    BEQ NO_GO ; If yes, then Command is Invalid
   
    MOVEM.L (A7)+,D6/A0 ; Restore Registers from Stack
    ADD.L #8,A7 ; Throw Two Long Words from Stack

* Jump to Adress
    JMP (A6) 
    
NO_GO JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D6/A0/A6 ; Restore Registers from Stack 
    RTS ; Return from Subroutine
*--------------------------------------------------------------------------------------------------------------------------


2.2.5-) MS (Memory Set)

Function: The "MS" (Memory Set) command is used to store data starting at a given address. Thus, this command requires two data inputs apart from the "Command Name". The address can be given as a hexadecimal number or a decimal number. On the other hand, the data can be a hexadecimal number, a decimal number or an ASCII string. If the data is an ASCII string, it must be enclosed within single quotes. If the command is entered incorrectly, an error message is displayed and the program returns to the terminal.

Syntax: "TUTOR 0.1> MS $2000 'Hello World!'<CR>"
		OR
	"TUTOR 0.1> MS 8192 'Hello World!'<CR>"
		OR
	"TUTOR 0.1> MS $2000 $2000<CR>"
		OR
	"TUTOR 0.1> MS 8192 $2000<CR>"
		OR
	"TUTOR 0.1> MS $2000 8192<CR>"
		OR
	"TUTOR 0.1> MS 8192 8192<CR>"



In all of the above examples, the data will be stored starting at the same address since $2000 (hexadecimal value) = 8192 (decimal value). In the first two examples, the ASCII encoded string "Hello World!" will be stored in memory, while in the last four cases , the number 8192 (decimal value) or $2000 (hexadecimal value) will be stored. Thus, there are six total ways this command can be structured.


How It Works: To execute the "MS" (Memory Set) command, the program needs to know the address at which to store the data. Since this is provided in the user input, the "GET_DATA" subroutine (discussed in the previous section) is used. This address is then put into an Address Register. Next, the input data is checked to see if it starts with a single quote character. If it does, the data is assumed to be a string and its ASCII encoded value is stored in consecutive memory locations starting at address in the Address Register. This is then null terminated to mark the end of the ASCII string. If the input data does not start with a single quote character, the data is assumed to be a number (hexadecimal/decimal) and is parsed from the input string using the "GET_DATA" subroutine. This is then stored in consecutive memory locations starting at address in the Address Register.



2.2.5.1-) MS Algorithm

Step 1: Save registers to Stack
Step 2: Get address to store data at in A1 // Calls subroutine "GET_DATA"
Step 3: Initialize A2-> current position of instruction pointer
Step 4: IF character at (A2) = '  '    // Check for leading space
	THEN go to Step 5
	ELSE go to Step 23  // Data Invalid
Step 5: IF character at (A2) = single quote character   // Check if data is an ASCII string
	THEN go to Step 6
	ELSE go to Step 16 // Data is a number
Step 6: IF character at (A2) = single quote // Check if data has ended
	THEN go to Step 7    // More data to store
	ELSE go to Step 11  // Data stored
Step 7: Store Data in (A1)
Step 8: A1 = A1 + 1  // Increment memory location
Step 9: A2 = A2 + 1 // Get next character to store
Step 10: Go to Step 6 // Loop till all data is stored
Step 11: Store null at the end of the data in memory
Step 12: Display starting address on screen
Step 13: Display null terminated saved ASCII string // To show that data has been stored successfully
Step 14: Restore registers from Stack
Step 15: Return from subroutine
Step 16: Get data to store in D2 // Calls subroutine "GET_DATA"
Step 17: Store data in memory at (A1) // At start address
Step 18: Display starting address on screen
Step 19: Display saved data // To show that data has been stored successfully
Step 20: Restore registers from Stack 
Step 21: Return from subroutine 
Step 23: Display error message
Step 23: Restore registers from Stack
Step 24: Return from subroutine


2.2.5.2-) MS Flowchart



2.2.5.3-) MS Assembly Code 

*--------------------------------------------------------------------------------------------------    
MS
* Stores Hexadecimal/Decimal/ASCII String Input Starting at Inputted Memory Address
*
    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D0-D3/D6/A0-A4,-(A7) ; Save Registers to Stack
    
* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0),A1 ; Get First Address in A1

* Look for Space Character followed by a Single Quote
    LEA INP_PTR,A4 ; Get Address of Input Pointer Location in A4
    MOVE.L (A4),A3 ; Get Current Location of Input Pointer in A3
    
    CMP.B #$20,(A3)+ ; Check if Next Character is a Space
    BNE MS_INV ; If no, then Command is Invalid
    
    CMP.B #$27,(A3)+ ; Check if Next Character is a Single Quote
    BNE MS_NUMBER ; If no, then Data is not an ASCII String
    
    MOVE.L A3,A2 ; Store Starting Address of String Input in A2
    
* Check if String Ends with Single Quote
STR_LOOP CMP.B #$27,(A3)+ ; Check if Next Character is a Single Quote
    BEQ STR_END ; If yes, then Reached End of String
    
    CMP.B #0,-(A3) ; Check if Character is null
    BEQ MS_INV ; If yes, then Command is Invalid
    ADD.L #1,A3 ; Go to Next Character
    BRA STR_LOOP ; If no, then Keep Looping 
    
STR_END MOVE.L A3,(A4) ; Store Current Location of Input Pointer in INP_PTR

    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 1
    BEQ MS_INV ; If yes, then Command is Invalid
    
    MOVE.L A1,A4 ; Save Start Address in A4
    
* Memory Set Operation with ASCII String Data
MS_LOOP CMP.B #$27,(A2) ; Check if Next Character is a Single Quote
    BEQ MS_END ; If yes, then Memory Set Complete
    
    MOVE.B (A2)+,(A1)+ ; Set Memory
    BRA MS_LOOP ; Loop till End of String 
    
MS_END MOVE.B #0,(A1)+ ; Terminate String With Null Character

* Confirm that Memory Set was Successful

* Display Address
    MOVE.L A4,D2 ; Get START Address in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display Address
    
    JSR SPACE ; Leave a Blank Space
   
* Display String
    JSR QUOTE ; Display Single Quote
    
    MOVE.L A4,A1 ; Get Start Address of Stored String in A1
    MOVE.B #14,D0 ; Set TRAP Function to Output Null Terminated String Starting at A1
    TRAP #15
    
    JSR QUOTE ; Display Single Quote
    
    JSR NEWLINE ; Leave Blank Line
    
    MOVEM.L (A7)+,D0-D3/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine

* Memory Set Operation with ASCII String Data
MS_NUMBER 
* Get Hexadecimal/Decimal Data
    LEA DATA1,A0 ; Set Pointer to Second Data Save Location
    JSR GET_DATA ; Get Data
    MOVE.L (A0),D2 ; Get Data in D2
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 1
    BEQ MS_INV ; If yes, then Command is Invalid

    CMP.L #$FF,D2 ; Check if D2 > $FF
    BGT MS_1 ; If no, then Data is Larger than a Byte

* Write Byte Size Data to Address
    MOVE.B D2,(A1)
    BRA MS_3 ; Already know Size of Data
    
MS_1 CMP.L #$FFFF,D2 ; Check if D2 > $FFFF
    BGT MS_2 ; If no, then Data is Larger than a Word
    
* Write Word Size Data to Address
    MOVE.W D2,(A1)
    BRA MS_3 ; Already know Size of Data
    
MS_2 
* Write Log Word Size Data to Address
    MOVE.L D2,(A1)
    
MS_3 
* Display Address
    MOVE.L D2,D0 ; Save D2 in D0
    MOVE.L A1,D2 ; Get START Address in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display Address
    MOVE.L D0,D2 ; Restore D2
    
    JSR SPACE ; Leave a Blank Space
 
    CMP.L #$FF,D2 ; Check if D2 > $FF
    BGT MS_4 ; If no, then Data is Larger than a Byte
    
* Confirm that Byte Size Data was Written to Address
    MOVE.B (A1),D2
    MOVE.B #1,D3 ; Number of Bytes to Display = 1
    BRA MS_6 ; Already know Size of Data
    
MS_4 CMP.L #$FFFF,D2 ; Check if D2 > $FFFF
    BGT MS_5 ; If no, then Data is Larger than a Word
    
* Confirm that Word Size Data was Written to Address
    MOVE.W (A1),D2
    MOVE.B #2,D3 ; Number of Bytes to Display = 2
    BRA MS_6 ; Already know Size of Data
    
MS_5
* Confirm that Long Word Size Data was Written to Address
    MOVE.L (A1),D2
    MOVE.B #4,D3 ; Number of Bytes to Display = 4
    
MS_6 JSR DISPREG ; Display Value of Data Written to Memory
    
    JSR NEWLINE ; Leave a Blank Line 
    
    MOVEM.L (A7)+,D0-D3/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine
       
MS_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0-D3/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine

*-------------------------------------------------------------------------------------------------






2.2.6-) BSCH

Function: The "BSCH" (Block Search) command is used to search for a literal string in memory. The bounds of the memory locations to search in are to be inputted by the user. These can be given as hexadecimal or decimal numbers. Also, the literal string to be searched must be entered within single quotes. Thus, altogether, this command requires three input data. Once the command is executed, the subroutine searches for the string in the memory locations and displays the start addresses of all matches along with the message "STRING LOCATED!". If no matches are found, the subroutine displays the message "STRING NOT FOUND!". Lastly, if the command is entered incorrectly, or if the input data is an empty string literal, an error message is displayed and the program returns to the terminal.

Syntax: "TUTOR 0.1> BSCH $2000 $3000 'Hey'<CR>"
		OR
            "TUTOR 0.1> BSCH 8192 $3000 'Hey'<CR>"
		OR
	"TUTOR 0.1> BSCH $2000 12288 'Hey'<CR>"
		OR
	"TUTOR 0.1> BSCH 8192 12288 'Hey'<CR>"


In all of the above examples, the literal string will be searched for in the same range of memory locations since $2000 (hexadecimal value) = 8192 (decimal value) and $3000 (hexadecimal value) = 12288 (decimal value) . Thus, there are four total ways this command can be structured.


How It Works: To execute the "BSCH" (Block Search) command, the program needs to know the address range in which to search for the string literal. Since these are provided in the user input, the "GET_DATA" subroutine (discussed in the previous section) is used. These addresses are then put into two Address Registers. Next, the input data is checked to see if it starts with a valid ASCII string (data surrounded by single quotes). If it is, the subroutine compares the ASCII encoded characters of the string to the data in the memory locations bound by the limits in the two Address Registers. If any match is found, the subroutine displays a success message followed by starting addresses and data for all matches. If no matches are found, a failure message is displayed. Lastly, if the input data is (a) not a valid string literal, (b) an empty string literal, or (c) not terminated by the carriage return, then an error message is displayed and the subroutine does not search for string matches.




2.2.6.1-) BSCH Algorithm

Step 1: Save registers to Stack
Step 2: Get start address to search string in A1 // Calls subroutine "GET_DATA"
Step 3: Get end address to search string in A2 // Calls subroutine "GET_DATA"
Step 4: Initialize A3-> current position of instruction pointer
Step 5: IF character at (A3) = '  '    // Check for leading space
	THEN go to Step 6
	ELSE go to Step 19  // Data invalid
Step 6: IF character at (A2) = single quote character   // Check if data is an ASCII string
	THEN go to Step 7
	ELSE go to Step 19 // Data invalid
Step 7: IF character at (A2) = single quote // Check if data has ended
	THEN go to Step 8    // Keep searching
	ELSE go to Step 10 // String match found
Step 8: A1 = A1 + 1  // Increment memory location
Step 9: IF A2 > A1    // Address range exhausted
	THEN go to Step 15    // Done searching
	ELSE go to Step 7  // Keep searching
Step 10: Set flag D0 // Flag set = match found
Step 11: Display address on screen // Address at which match is found/
Step 12: Display matched string 
Step 13: Display success message
Step 14: Go to Step 7   // Keep searching
Step 15: IF flag D0 is Set    // D0  = 1 means match found
	THEN go to Step 17   // End of subroutine
	ELSE go to Step 16  // No match found
Step 16: Display failure message 
Step 17: Restore registers from Stack 
Step 18: Return from subroutine 
Step 19: Display error message
Step 20: Restore registers from Stack 
Step 21: Return from subroutine 

2.2.6.2-) BSCH Flowchart

2.2.6.3-) BSCH Assembly Code 

*---------------------------------------------------------------------------------------------------------    
BSCH
* Searches for a String in Memory
* Returns all matches

    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D0-D4/A0-A5,-(A7) ; Save Registers to Stack
    
* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A1 ; Get First Address in A1, and then Set Pointer to Second Data Save Location
    
* Get END Address in A2
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A2 ; Get First Address in A2, and then Set Pointer to Third Data Save Location

* Look for Space Character followed by a Single Quote
    LEA INP_PTR,A5 ; Get Address of Input Pointer Location in A5
    MOVE.L (A5),A4 ; Get Current Location of Input Pointer in A4
    
    CMP.B #$20,(A4)+ ; Check if Next Character is a Space
    BNE BSCH_INV ; If no, then Command is Invalid
    
    CMP.B #$27,(A4)+ ; Check if Next Character is a Single Quote
    BNE BSCH_INV ; If no, then Command is Invalid
    
    MOVE.L A4,A3 ; Store Starting Address of String Input in A3
    
* Check if String Ends with Single Quote and has at least one character
    CMP.B #$27,(A4)+ ; Check if Next Character is a Single Quote
    BEQ BSCH_INV ; If yes, Command is Invalid Since String Cannot Be Empty
    SUB.L #1,A4 ; If no, Go Back to Previous Character

BSTR_LOOP CMP.B #$27,(A4)+ ; Check if Next Character is a Single Quote
    BEQ BSTR_END ; If yes, then Reached End of String
    
    CMP.B #0,-(A4) ; Check if Character is null
    BEQ BSCH_INV ; If yes, then Command is Invalid
    ADD.L #1,A4 ; Go to Next Character
    BRA BSTR_LOOP ; If no, then Keep Looping 
    
BSTR_END MOVE.L A4,(A5) ; Store Current Location of Input Pointer in INP_PTR

    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 1
    BEQ BSCH_INV ; If yes, then Command is Invalid
    
    CLR.L D4 ; Clear Flag to Check if String is Found
    
BSCH_NO CMPA.L A1,A2 ; Check if A2 <= A1
     BLE BSCH_DONE ; If yes, Search Exhausted
     MOVE.L A3,A4  ; Make a copy of Start Address of Input String
     MOVE.L A1,A5  ; Save Start Address of Located String in A5
BSCH_YES  CMPA.L A1,A2 ; Check if A2 <= A1
     BLE BSCH_DONE ; If yes, Search Exhausted
     MOVE.B (A4)+,D1 ; Get character from Input String in D1
     CMP.B #$27,D1 ; Check if Character is a Single Quote
     BEQ BSCH_MATCH ; If yes, then Match Found
     MOVE.B (A1)+,D2 ; Get character to Compare with in D2
     CMP.B D1,D2 ; Check if Characters Match
     BNE BSCH_NO ; If no, Restart Search from Following Address
     BRA BSCH_YES ; Continue Searching
       
BSCH_MATCH MOVE.L #1,D4 ; Set Flag to Denote String Was Found
    MOVE.B #16,D2 ; Set Base for Output Operation to 16

* Display Address
    
    MOVE.L A5,D2 ; Get START Address in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display Address
    
    JSR SPACE ; Leave a Blank Space
   
* Display String
    JSR QUOTE ; Display Single Quote
    
    MOVE.B #6,D0 ; Set TRAP Function to Output Character in D1.B

BSD_LOOP CMP.L A5,A1 ; Check if A1 <= A5
    BLE BSD_END ; If yes, then Memory Set Display Complete
    
    MOVE.B (A5)+,D1 ; Get Character in D1
    TRAP #15
    BRA BSD_LOOP ; Loop till End of String
    
BSD_END JSR QUOTE ; Display Single Quote

    JSR SPACE ; Leave Blank Space
    
    MOVE.L A1,A5 ; Save Value of A1 in A5
    
* Display Success Message
    LEA SFOUND,A1
    MOVE.B #13,D0
    TRAP #15
    MOVE.L A5,A1 ; Restore Value of A1
    
    BRA BSCH_NO ; Look for More Matches

BSCH_DONE CMP.L #1,D4 ; Check Flag to See if String Was Found
    BEQ BSCH_END ; If yes, then Block Search Complete
    
* Display Failure Message Since String Was Not Found
    LEA SLOST,A1
    MOVE.B #13,D0
    TRAP #15
    
BSCH_END MOVEM.L (A7)+,D0-D4/A0-A5 ; Restore Registers from Stack
    RTS ; Return from Subroutine
    
BSCH_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0-D4/A0-A5 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-------------------------------------------------------------------------------------------------------------------------






2.2.7-) BF (Block Fill)

Function: The "BF" (Block Fill) command is used to store a word sized data in memory locations within an address range. The bounds of the memory locations to fill are to be inputted by the user. These can be given as hexadecimal or decimal numbers. Also, these addresses need to be even numbers since this is a word size operation and therefore cannot be executed at odd locations. Finally, if the command is entered incorrectly, an error message is displayed and the program returns to the terminal.

Syntax: "TUTOR 0.1> BF $2000 $3000 $2500<CR>"
		OR
            "TUTOR 0.1> BF 8192 $3000 $2500<CR>"
		OR
	"TUTOR 0.1> BF $2000 12288 $2500<CR>"
		OR
	"TUTOR 0.1> BF 8192 12288 $2500<CR>"
		OR
	"TUTOR 0.1> BF $2000 $3000 9472<CR>"
		OR
            "TUTOR 0.1> BF 8192 $3000 9472<CR>"
		OR
	"TUTOR 0.1> BF $2000 12288 9472<CR>"
		OR
	"TUTOR 0.1> BF 8192 12288 9472<CR>"




In all of the above examples, the same word size data ($2500 = 9472) will be filled in all memory locations in the same address range since $2000 (hexadecimal value) = 8192 (decimal value) and $3000 (hexadecimal value) = 12288 (decimal value) . Thus, there are eight total ways this command can be structured.


How It Works: To execute the "BF" (Block Fill) command, the program needs three adresses as mentioned. These can be parsed from the user input using the "GET_DATA" subroutine. These addresses are then put into three Address Registers. Following this, data is copied from the source memory block starting at the source start address and is saved in consecutive memory locations begining at the destination start address. This goes on till all the data from the source memory block have been copied over. In the event that one of the inputted data is not a valid address, an error message is displayed and the Block Fill operation is not executed.




2.2.7.1-) BF Algorithm

Step 1: Save registers to Stack
Step 2: Get start address of block in A1 // Calls subroutine "GET_DATA"
Step 3: IF address is even // Required for word operations
	THEN go to Step 4   
	ELSE go to Step 14 // Invalid Address
Step 4: Get end address of block in A2 // Calls subroutine "GET_DATA"
Step 5: IF address is even // Required for word operations
	THEN go to Step 6   
	ELSE go to Step 14// Invalid Address
Step 6: Get input data in D0 // Calls subroutine "GET_DATA"
Step 7: IF D0  < $FFFF   // Word sized data
	THEN go to Step 8
	ELSE go to Step 14 // Invalid Data
Step 8: IF A2 > A1 // Still inside block
	THEN go to Step 9
	ELSE go to Step 12  // Operation complete
Step 9: Store data in (A1)   // Block fill
Step 10: A1 = A1 + 1  // Increment memory location
Step 11: Go to Step 5  // Loop while inside block
Step 12: Restore registers from Stack 
Step 13: Return from subroutine 
Step 14: Display error message
Step 15: Restore registers from Stack 
Step 16: Return from subroutine 

2.2.7.2-) BF Flowchart

2.2.7.3-) BF Assembly Code 

*---------------------------------------------------------------------------------------------------
BF
* Fills Block of Memory With Inputted Word Size Data
*
    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D0/D6/A0-A2,-(A7) ; Save Registers to Stack
    
* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A1 ; Get First Address in A1, and then Set Pointer to Second Data Save Location
    
* Check if START Address is Even
    MOVE.L A1,D0 ; Get Address in D0
    BTST #0,D0 ; Check if D0 is even
    BNE BF_INV ; If no, then Address is Invalid

* Get END Address in A2
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A2 ; Get Second Address in A2, and then Set Pointer to Third Data Save Location
    
* Check if END Address is Even
    MOVE.L A2,D0 ; Get Address in D0
    BTST #0,D0 ; Check if D0 is even
    BNE BF_INV ; If no, then Address is Invalid
    
* Get Data in D0
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0),D0 ; Get Data in D0
    
* Check if Data is Word Size
    CMP.L #$FFFF,D0 ; Check id D0 > Largest Word
    BGT BF_INV ; If yes, then Data is not Word Size
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 1
    BEQ BF_INV ; If yes, then Command is Invalid

BF_LOOP CMP.L A1,A2 ; Check if A2 <= A1
    BLE BF_END ; If yes, then Block Fill Complete
    
    MOVE.W D0,(A1)+ ; Fill Word in the Block
    BRA BF_LOOP ; Loop While in Address Range

BF_END MOVEM.L (A7)+,D0/D6/A0-A2 ; Restore Registers from Stack
    RTS ; Return from Subroutine 
    
BF_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0/D6/A0-A2 ; Restore Registers from Stack
    RTS ; Return from Subroutine 
*-------------------------------------------------------------------------------------------------- 



2.2.8-) BMOV (Block Move)

Function: The "BMOV" (Block Move) command is used to move data from one block of memory locations to another. Accordingly, this subroutine requires three input addresses: (1) starting address of the source, (2) ending address of the source, and (3) starting address of the destination. Each of these addresses can be given as hexadecimal or decimal numbers. Note that the end address of the destination is not inputted because it can easily be calculated from the size of the source memory block if needed. Also. it is preferrable not to have the destination address lying within the source block of memory locations, to prevent ambiguity of data at these locations. If the command is entered appropriately, this subroutine will copy over data from an entire range of memory locations to another area in memory. Otherwise, an error message is displayed and the program returns to the terminal.

Syntax: "TUTOR 0.1> BMOV $2000 $2500 $3000<CR>"
		OR
            "TUTOR 0.1> BMOV 8192 $2500 $3000<CR>"
		OR
	"TUTOR 0.1> BMOV $2000 $2500 12288<CR>"
		OR
	"TUTOR 0.1> BMOV 8192 $2500 12288<CR>"
		OR
	"TUTOR 0.1> BMOV $2000 9472 $3000<CR>"
		OR
            "TUTOR 0.1> BMOV 8192 9472 $3000<CR>"
		OR
	"TUTOR 0.1> BMOV $2000 9472 12288<CR>"
		OR
	"TUTOR 0.1> BMOV 8192 9472 12288<CR>"



In all of the above examples, data residing with memory locations $2000 (8192) and $2500 (9472) is copied over to memory locations between $3000 (12288) and $3500 (13568). Thus, there are eight total ways this command can be structured.


How It Works: To execute the "BMOV" (Block Move), the program needs to know the address range  to fill the inputted word size data in. Since these are also provided in the user input, the "GET_DATA" subroutine (discussed in the previous section) is used. These addresses are then put into two Address Registers. Also, one must note that since this is a word size operation, both the addresses must be even. Next, the input is checked to see if it a word size datum. If it is, all memory locations within the range are fill with this datum, one word at a time. If not, then an error message is displayed and the Block Fill operation is not executed.


2.2.8.1-) BMOVAlgorithm

Step 1: Save registers to Stack
Step 2: Get start address of source block in A1 // Calls subroutine "GET_DATA"
Step 3: Get end address of source block in A2 // Calls subroutine "GET_DATA"
Step 4: Get start address of destination block in A3 // Calls subroutine "GET_DATA"
Step 5: Initialize A4-> current position of instruction pointer
Step 6: IF character at (A4) = null    // Check for carriage return
	THEN go to Step 7
	ELSE go to Step 14  // Data invalid
Step 7: IF A2 > A1 // Still inside block
	THEN go to Step 8
	ELSE go to Step 12  // Operation complete
Step 8: Copy data from (A1) to (A3)   // Block Move
Step 9: A1 = A1 + 1  // Increment source memory location
Step 10: A3 = A3 + 1  // Increment memory location
Step 11: Go to Step 7  // Loop while inside block
Step 12: Restore registers from Stack 
Step 13: Return from subroutine 
Step 14: Display error message
Step 15: Restore registers from Stack 
Step 16: Return from subroutine 




2.2.8.2-) BMOV Flowchart

2.2.8.3-) BMOVAssembly Code 

*--------------------------------------------------------------------------------------------------    
BMOV
* Copy a Block of Memory from One Place to Another
* Inputs: Start & End Address of Source, Start Address of Destination

    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D6/A0-A3,-(A7) ; Save Registers to Stack 
    
* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A1 ; Get First Address in A1, and then Set Pointer to Second Data Save Location

* Get END Address in A2
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A2 ; Get Second Address in A2, and then Set Pointer to Third Data Save Location
    
* Get START Address #2 in A3
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0),A3 ; Get Second Address in A2
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 1
    BEQ BMOV_INV ; If yes, then Command is Invalid

BMOV_LOOP CMP.L A1,A2 ; Check if A2 <= A1
    BLE BMOV_END ; If yes, then Block Move Complete
    
    MOVE.B (A1)+,(A3)+ ; Move Byte from Block
    BRA BMOV_LOOP ; Loop While in Address Range

BMOV_END MOVEM.L (A7)+,D6/A0-A3 ; Restore Registers from Stack
    RTS ; Return from Subroutine
    
BMOV_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D6/A0-A3 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-------------------------------------------------------------------------------------------   

2.2.9-) BTST (Block Test)

Function: "BTST" (Block Test) is a destructive test of a block of memory. The memory is tested by consecutively writing and reading different types of data to see whether the written value is actually maintained by the memory locations or not. If the memory block passes this test, a success message is displayed on the screen. If not, a failure message is displayed, followed by additional information regarding the reasons behind the failure. This includes the address of memory location where the Block Test failed, the value written to the memory, and the actual (different) value read from the location. For the Monitor program, the hexadecimal numbers '$AA' and '$55' are used to test memory blocks as they are alternate zeroes and ones (10101010 and 01010101), thus making it possible to test every value for every bit of data in the block of memory. Lastly, the addresses inputted by the user can be either hexadecimal or decimal numbers. Note however, that if the addresses inputted are invalid, the Block Test operation is not be performed. Instead, an error message is displayed and the program returns to the terminal.



Syntax: "TUTOR 0.1> BTST $2000 $3000<CR>"
		OR
            "TUTOR 0.1> BTST 8192 $3000<CR>"
		OR
	"TUTOR 0.1> BTST $2000 12288<CR>"
		OR
	"TUTOR 0.1> BTST 8192 12288<CR>"



In all of the above examples, the block of memory ranging from addresses $2000 (8192) to$3000 (12288) is being tested. Thus, there are eight total ways this command can be structured.

How It Works: Before performing the Block Test operation, the subroutine needs to acquire the start and end address of the block of memory to be tested. It does so by using the GET_DATA" subroutine to parse the addresses from the input string. Next, the subroutine checks if the command is appropriately terminated using a carriage return. If not, an error message is displayed, and the program returns to the terminal. If it is entered correctly, the Block Test operation begins. First, the byte "$AA" is written to all memory locations within the block of memory. This is followed by a read operation for the entire block. When each byte is read, it is compare with "$AA". If it matches, the subroutine moves on to the next address. If it doesn't match, the corresponding address, value written (here $AA), and value read are displayed on the screen with a failure message. If the entire block checks out, the same operation is carried out once again, but this time using the byte "$55" instead of "$AA". If this also checks out, a success message is displayed on the screen, after which the program returns to the terminal.



2.2.9.1-) BTST Algorithm

Step 1: Save registers to Stack
Step 2: Get start address of block in A1 // Calls subroutine "GET_DATA"
Step 3: Get end address of block in A2 // Calls subroutine "GET_DATA"
Step 4: Initialize A4-> current position of instruction pointer
Step 5: IF character at (A4) = null    // Check for carriage return
	THEN go to Step 6
	ELSE go to Step 23  // Data invalid
Step 6: IF A2 > A1 // Still inside block
	THEN go to Step 7 
	ELSE go to Step 10 // Write successful
Step 7: Write $AA into (A1) // Write operation loop
Step 8: A1 = A1 + 1  // Increment memory location
Step 9: Go to Step 6  // Loop while inside block
Step 10: Get start address of block in A1 
Step 11: IF A2 > A1 // Still inside block
	THEN go to Step 12
	ELSE go to Step 16  // Read successful
Step 12: Read from (A1) // Read operation loop
Step 13: IF (A1) = $AA // Check Written Value
	THEN go to Step 14
	ELSE go to Step 20 // Write unsuccessful
Step 14: A1 = A1 + 1  // Increment memory location
Step 15: Go to Step 6  // Loop while inside block
Step 16: Get start address of block in A1 
Step 17: Repeat Steps 6 to 15 using $55 instead of $AA
Step 18: Display success message
Step 19: Go to Step 21
Step 20: Display failure message, address, written value & read value
Step 21: Restore registers from Stack 
Step 22: Return from subroutine 
Step 23: Display error message
Step 24: Restore registers from Stack 
Step 25: Return from subroutine 

2.2.9.2-) BTST Flowchart

2.2.9.3-) BTST Assembly Code 

*-------------------------------------------------------------------------------------------    
BTST
* Desctructive Test for a Memory Block
* Data is Alternatively Read & Written to Ensure that the Memory Location can Maintain Data

    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D0-D5/A0-A3,-(A7) ; Save Registers to Stack
    
* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A1 ; Get First Address in A1, and then Set Pointer to Second Data Save Location

* Get END Address in A2
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A2 ; Get Second Address in A2, and then Set Pointer to Third Data Save Location
    
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 1
    BEQ BTST_INV ; If yes, then Command is Invalid

    MOVE.L A1,A0 ; Make Copy of START Address in A0
    MOVE.L A0,A3 ; Make Copy of START Address in A3

    MOVE.B #$AA,D4 ; Data to be written
    
* Write Data to Block
BTST_LOOP1 CMP.L A1,A2 ; Check if A2 <= A1
    BLE BTST_NEXT1 ; If yes, then Block Write Complete
    
    MOVE.B D4,(A1)+ ; Write Byte to Block
    BRA BTST_LOOP1 ; Loop While in Address Range
    
BTST_NEXT1  ;MOVE.B #$3C,(A0) ; Create a Block Test Error at Starting Address

* Read Data from Block
BTST_LOOP2 CMP.L A0,A2 ; Check if A2 <= A0
    BLE BTST_PASS ; If yes, then Block Read Complete
    
    MOVE.B (A0)+,D5 ; Read Byte from Block into Temporary Register
    CMP.B D4,D5 ; Check if Read Value = Written Value
    BNE BTST_FAIL ; If no, then Block Test Failed
    BRA BTST_LOOP2 ; Loop While in Address Range
    
BTST_PASS MOVE.L A3,A0 ; Restore START Address in A0
    MOVE.L A3,A1 ; Restore START Address in A1
    
    CMP.B #$55,D4 ; Check if D4 = $55
    BEQ BTST_SUCCESS ; Passed both Block Tests
    
    MOVE.B #$55,D4 ; New Data to be Written
    BRA BTST_LOOP1 ; Perform Operation Twice
    
* Display Block Test Passed Message
BTST_SUCCESS LEA BPASS,A1
    MOVE.B #13,D0 ; Set TRAP Funtion to Output String Starting at A1 with CR
    TRAP #15
    BRA BTST_END ; End of Block Test
    
* Display Block Test Failed Message
BTST_FAIL LEA BFAIL,A1
    MOVE.B #13,D0 ; Set TRAP Funtion to Output String Starting at A1 with CR
    TRAP #15
    
* Display Failure Address
    MOVE.L A0,D2 ; Get Address of Latter Byte
    SUB.L #1,D2 ; Get Address of Failed Byte
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display Failure Address
    
    JSR SPACE ; Leave a Blank Space
    
* Display Written Byte
    MOVE.B #1,D3 ; Set Number of Bytes to Display = 1
    MOVE.L D4,D2 ; Data to be Written
    JSR DISPREG ; Display Written Byte
    
    JSR SPACE ; Leave a Blank Space
    
* Display Read Byte
    MOVE.L D5,D2 ; Data to be Written
    JSR DISPREG ; Display Read Byte
    
    JSR NEWLINE ; Print a Blank Line
    
BTST_END MOVEM.L (A7)+,D0-D5/A0-A3 ; Restore Registers from Stack
    RTS ; Return from Subroutine
    
BTST_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0-D5/A0-A3 ; Restore Registers from Stack
    RTS ; Return from Subroutine

*--------------------------------------------------------------------------------------------------------------------------







2.2.10-) MDSP (Memory Display)

Function: The command "MDSP" (Memory Display) is used to display data in consecutive memory locations. One or two addresses are inputs to this command. These addresses can be given as hexadecimal or decimal numbers. If two addresses are inputted, this command displays the memory locations and their contents for all addresses within the given range (last address excluded). On the other hand, if only one address is inputted, by default, the command will display 16 consecutive memory locations and their contents, starting at the inputted address. If any of the inputs are invalid, an error message is displayed and the memory display operation is not executed.




Syntax: "TUTOR 0.1> MDSP $2000<CR>"
		OR
            "TUTOR 0.1> MDSP $2000 $3000<CR>"



In the first example, the subroutine will display the addresses and contents of 16 consecutive memory locations starting at $2000 (i.e. $2000 to $200F). On the other hand, the second example command will display addresses and contents for all memory locations between $2000 and $3000.

How It Works: In order to display addresses and contents of memory locations to the terminal, the subroutine must be provided with one or two addresses. This is achieved through the use of the "GET_DATA" subroutine. If there are two addresses, they are stored in two separate Address Registers. If only one is given, this address is placed in both the Address Registers, and then 16 is added to the second one. The subroutine now has everything it needs and thus begins displays addresses and contents of memory locations between the two addresses. If for some reason the inputs are erroneous, an error message is displayed and the program returns to the terminal.


2.2.10.1-) MDSP Algorithm

Step 1: Save registers to Stack
Step 2: Get start address of block in A1 // Calls subroutine "GET_DATA"
Step 3: Initialize A4-> current position of instruction pointer
Step 4: IF character at (A4) = null    // Check for carriage return
	THEN go to Step  7   // No second address
	ELSE go to Step 5
Step 5: Get end address of block in A2 // Calls subroutine "GET_DATA"
Step 6: IF character at (A4) = null    // Check for carriage return
	THEN go to Step  8
	ELSE go to Step 15 // Invalid command
Step 7: A2 = A1 + 16 // Default operation
Step 8: IF A2 > A1 // Still inside block
	THEN go to Step 9
	ELSE go to Step 13  // Operation complete
Step 9: Display address to terminal
Step 10: Display byte sized data from address
Step 11: A1 = A1 + 1  // Increment memory location
Step 12: Go to Step 8  // Loop while inside block
Step 13: Restore registers from Stack 
Step 14: Return from subroutine 
Step 15: Display error message
Step 16: Restore registers from Stack 
Step 17: Return from subroutine 


	2.2.10.2-) MDSP Flowchart

2.2.10.3-) MDSPAssembly Code 

*-----------------------------------------------------------------------------------------------------------------------------------
MDSP
* If 2 Addresses Inputted : Displays Addresses and Contents of All Memory Locations Between Addresses
* If 1 Addresse Inputted : Displays Addresses and Contents of 16 Consecutive Memory Locations Starting at Address

    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D0-D3/D6/A0-A4,-(A7) ; Store Registers on Stack
    
* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A1 ; Get First Address in A1, and then Set Pointer to Second Data Save Location

* Check if Second Address Inputted
    LEA INP_PTR,A4 ; Get Address of Input Pointer Location in A4
    MOVE.L (A4),A3 ; Get Current Location of Input Pointer in A3
    MOVE.B (A3),D0 ; Get Character at Current Pointer Location in D0
    BNE GET2ADR ; If character is not null, then Get Second Address
    MOVE.L A1,A2 ; Copy A1 to A2
    ADD.L #16,A2 ; A2 = A1 + 16
    BRA START_MDSP
    
GET2ADR 
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0),A2 ; Get Second Address in A2
    
START_MDSP  
    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6 ; Check if D6 = 1
    BEQ MD_INV ; Command is Invalid
    
    
MD_LOOP CMP.L A1,A2 ; Check if A2 <= A1
    BLE MD_DONE ; If yes, then MD_DONE
    
    MOVE.L A1,D2 ; Get Address in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Output Address

    JSR SPACE ; Output Space Character
    
    MOVE.B (A1)+,D2 ; Get Byte Size Data in D2
    MOVE.B #1,D3 ; Set Number of Bytes to Display = 1
    JSR DISPREG ; Output a Byte in Hex
  
    JSR NEWLINE ; Output Newline Character
    
    BRA MD_LOOP ; Loop While Still in Address Range
    
MD_DONE MOVEM.L (A7)+,D0-D3/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine
    
MD_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0-D2/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine    
*--------------------------------------------------------------------------------------------- 


2.2.11-) MM (Memory Modify)

Function: The "MM" (Memory Modify) command performs the dual task of displaying as well as allowing the user to modify memory locations. There are three supported modes of operation: 'B' (byte size), 'W' (word size), and 'L' (wong word size). This command uses one input which serves as the start address for the memory modify operation. This address can be given as a hexadecimal or a decimal number. If the mode of operation is not specified, the default "word size" operation is executed. This command will display a memory location starting at the specified address and wait for user input. If the user inputs a number, it is stored in that memory location. If the number is larger than the size of opeation, an error message is displayed and the memory modify operation ends. If the user enters a carriage return without entered any data, the contents of the memory location will not be modified. Finally, the memory modify operation will continue until one of the following occurs: (1) the user enters a period (".") followed by a carriage return, or (2) the user enters invalid data which causes the program to display an error message and stop the memory modify operation.

Modes: 'B' -> Byte Operation
	 'W' -> Word Operation (Default)
	  'L' -> Long Word Operation


Syntax: "TUTOR 0.1> MM $2000<CR>"
		OR
            "TUTOR 0.1> MM $2000;B<CR>"
		OR
            "TUTOR 0.1> MM $2000;W<CR>"
		OR
            "TUTOR 0.1> MM $2000;L<CR>"


The first and third example commands perform the exact same operation: word size data is displayed at the terminal along with their addresses starting at $2000, and the user can input word size data to modify the data. In the second example, the same operation is perfomed, except that bytes are used instead of words. Similarly, the last command is an example of a long word size operation.

How It Works: In order to display addresses and contents of memory locations to the terminal, the subroutine must be provided with a starting address. This is achieved through the use of the "GET_DATA" subroutine. This address is then placed in an Address. Next, the subroutine checks if a mode of operation has been inputted by looking for the semicolon (";") symbol. If so, it sets a Data Register to an appropriate value based on the mode selected. If no mode is selected, the word size operation is performed by default. The subroutine now has everything it needs and thus begins displays addresses and contents of memory locations starting at the inputted address. After displaying each datum, the subroutine waits for user input. If a period (".") followed by a carriage return is entered, the subroutine exits the memory modify loop and returns to the terminal. If a carriage return is entered, the subroutine doesn't modify the contents of the memory location, but moves on to the next address. If a hexadecimal or a decimal number is entered (with a leading space character), the subroutine stores the entered number in the current memory location and then moves on to the next address. Finally, if the user entered number is larger than the size of operation, or if the number is invalid, an error message is displayed and the program returns to the terminal.




2.2.11.1-) MM Algorithm

Step 1: Save registers to Stack
Step 2: Get start address of block in A1 // Calls subroutine "GET_DATA"
Step 3: Initialize A4-> current position of instruction pointer
Step 4: IF character at (A4) = null    // Check for carriage return
	THEN go to Step  10   // Default Mode
	ELSE go to Step 5
Step 5: IF character at (A4) = ';'    // Check for semicolon
	THEN go to Step  6  
	ELSE go to Step  27 // Invalid command
Step 6: A4 = A4 + 1 // Go to next character
Step 7: IF character at (A4) =  'B'  
	THEN go to Step 12    // Byte operation
	ELSE go to Step 8
Step 8: IF character at (A4) =  'L'  
	THEN go to Step 14  // Long word operation
	ELSE go to Step 9
Step 9: IF character at (A4) =  'W'  
	THEN go to Step  10 // Word operation
	ELSE go to Step 27 // Invalid command
Step 10: Set D0 = 1 // For word size operation
Step 11: Go to Step 15
Step 12: Set D0 = 0 // For byte size operation
Step 13: Go to Step 15
Step 14: Set D0 = 2 // For long word operation
Step 15: Display address to terminal
Step 16: Display data from address  // Size depends on mode of operation
Step 17: IF character at (A4) = '.'    // Check for period
	THEN go to Step  25 // Operation complete
	ELSE go to Step 18
Step 18: IF character at (A4) = null    // Check for semicolon
	THEN go to Step  23 // Don't modify memory
	ELSE go to Step  19
Step 19: IF character at (A4) = ' '     // Check for space
	THEN go to Step  20  // Number entered
	ELSE go to Step  27 // Invalid command
Step 20: Get number in D1 // Calls subroutine "GET_DATA"
Step 21: IF number < size of operation 
	THEN go to Step  22  
	ELSE go to Step 27  // Invalid number
Step 22: Store number in memory  // Memory modify
Step 23: A1 = A1 + 1  // Increment memory location
Step 24: Go to Step 15  // Loop till period entered
Step 25: Restore registers from Stack 
Step 26: Return from subroutine 
Step 27: Display error message
Step 28: Restore registers from Stack 
Step 29: Return from subroutine 


2.2.11.2-) MM Flowchart

2.2.11.3-) MM Assembly Code 

*-----------------------------------------------------------------------------------------------  
MM
* Displays Address and Contents of Memory Locations Starting at Inputted Address
* Enter Number at the Terminal to Modify the Memory Contents
* Enter Carriage Return at the Terminal to Go to Next Address Without Modifying the Memory Contents
* Enter Period to Exit MM command loop

    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D0-D4/D6/A0-A4,-(A7) ; Save Registers to Stack
    
* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A2 ; Get First Address in A2, and then Set Pointer to Second Data Save Location
    
* Check if Command String has Ended
    LEA INP_PTR,A3 ; Get Address of Stored Pointer Location
    MOVE.L (A3),A4 ; Get Current Input Pointer Address in A4
    
    CMP.B #0,(A4) ; Check if Character is null
    BEQ MODEW ; If yes, Perform Default Operation, i.e Word Mode
    
* Check for ';' Character
    CMP.B #$3B,(A4) ; Check if Character is ';'
    BNE MM_INV ; If no, then Command is Invalid
    
    MOVE.L A4,(A3) ; Save Current Input Pointer Location in INP_PTR
    
* Check Mode of Operation
    JSR GET_MODE ; Get Mode from Input
    MOVE.L (A0)+,D0 ; Get Mode in D0, and then Set Pointer to Third Data Save Location
    
    CMP.L #$42,D0 ;Check if Mode = 'B'
    BEQ MODEB ; If yes, then Perform Operation in Byte Mode
    
    CMP.L #$4C,D0 ;Check if Mode = 'L'
    BEQ MODEL ; If yes, then Perform Operation in Long Word Mode
    
    CMP.L #$57,D0 ;Check if Mode = 'W'
    BNE MM_INV ; If no, then Command is Invalid
    
MODEW MOVE.L #1,D4 ; D4 = 1 for Word Operation
    BRA MM_START ; Start Memory Modify Operation
MODEB CLR.L D4 ; D4 = 0 for Byte Operation
    BRA MM_START ; Start Memory Modify Operation
MODEL MOVE.L #2,D4 ; D4 = 2 for Long Word Operation

MM_START
    JSR CHK_END ; Check if Command String is at End
    CMP.B #1,D6 ; Check if D6 = 0
    BEQ MM_INV ; If yes, then Command is Invalid

    CLR.L D3 ; Clear Data Input Register
    MOVE.B #16,D2 ; Set Base to 16 for TRAP Function #15
    
MM_LOOP MOVE.B #15,D0 ; Set TRAP Function to Display D1.L in Base D2.B
    
    MOVE.L A2,D2 ; Get Address in D2
    MOVE.B #2,D3 ; Size of Output = 2 Bytes
    JSR DISPREG ; Output Address

    JSR SPACE ; Output Space Character
    
    CLR.L D1 ; Clear Output Register 
    
* Byte Read Operation 
    CMP.L #0,D4 ; Check if D4 = 0 (for Byte Operation)
    BNE MM_N1 ; If no, then Next
    
    MOVE.B (A2),D2 ; Output a Byte
    MOVE.B #1,D3 ; Size of Output = 1 Byte
    BRA MM_READ ; Perform Read Operation

* Word Read Operation 
MM_N1 CMP.L #1,D4 ; Check if D4 = 1 (for Word Operation)
    BNE MM_N2 ; If no, then Next
    
    MOVE.W (A2),D2 ; Output a Word
    MOVE.B #2,D3 ; Size of Output = 2 Bytes
    BRA MM_READ ; Perform Read Operation
    
* Long Word Read Operation   
MM_N2 MOVE.L (A2),D2 ; Output a Long
    MOVE.B #4,D3 ; Size of Output = 4 Bytes

MM_READ JSR DISPREG ; Output Data 

    MOVE.B #$3E,D1 ; Set Character '>' for Output
    MOVE.B #6,D0 ; Set TRAP Function to Output Character in D1.B
    TRAP #15

* Get Input Data
    LEA MM_INPUT,A1 ; Input
    MOVE.B #2,D0
    TRAP #15  
    
* Check for '.'
    CMP.B #$2E,(A1) ; Check if Character = '.'
    BEQ MM_DONE ; If yes, then Memory Modify Complete
    
* Check for null
    CMP.B #0,(A1) ; Check if Character = null
    BNE MM_WRITE ; If yes, then Modify Current Location
    
* Byte Skip Operation 
    CMP.L #0,D4 ; Check if D4 = 0 (for Byte Operation)
    BNE MM_N3 ; If no, then Next
    
    ADD.L #1,A2 Move to Next Byte
    BRA MM_LOOP ; Loop Till '.' is Entered

* Word Skip Operation 
MM_N3 CMP.L #1,D4 ; Check if D4 = 1 (for Word Operation)
    BNE MM_N4 ; If no, then Next
    
    ADD.L #2,A2 Move to Next Word
    BRA MM_LOOP ; Loop Till '.' is Entered
    
* Long Word Skip Operation   
MM_N4 ADD.L #4,A2 Move to Next Long Word
    BRA MM_LOOP ; Loop Till '.' is Entered
    
* Get Input Data in D0

MM_WRITE MOVE.L A1,(A3) ; Save Current Input Pointer Location in INP_PTR 

    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0),D0 ; Get Data in D0
    
* Byte Write Operation 
    CMP.L #0,D4 ; Check if D4 = 0 (for Byte Operation)
    BNE MM_N5 ; If no, then Next
    
    CMP.L #$FF,D0 ; Check if D0 > $FF
    BGT MM_INV ; If yes, then Data Invalid
    
    MOVE.B D0,(A2)+ ; Store Entered Byte in Memory
    BRA MM_WDONE ; Write Operation Done

* Word Write Operation 
MM_N5 CMP.L #1,D4 ; Check if D4 = 1 (for Word Operation)
    BNE MM_N6 ; If no, then Next
    
    CMP.L #$FFFF,D0 ; Check if D0 > $FFFF
    BGT MM_INV ; If yes, then Data Invalid
    
    MOVE.W D0,(A2)+ ; Store Entered Word in Memory
    BRA MM_WDONE ; Write Operation Done
    
* Long Word Write Operation   
MM_N6 MOVE.L D0,(A2)+ ; Store Entered Long Word in Memory

MM_WDONE BRA MM_LOOP ; Loop Till '.' is Entered
    
MM_DONE MOVEM.L (A7)+,D0-D4/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine
    
MM_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0-D4/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-------------------------------------------------------------------------------------------------- 

2.2.12-) SORTW (Sort Word)

Function: This command is used to sort word size data located between two inputted addresses. The data can be sorted in ascending or descending order depending on the user's need. This subroutine requires two input addresses (for the range of operation) and an optional mode of operation (ascending order is the default). These addresses can be given as hexadecimal or decimal numbers. Also, since this is a word size operation, the inputted addresses must both be even, or else an error message will be displayed, and the sort operation won't be executed.

Modes: 'A' -> Ascending Order (Default)
	 'D' -> Descending Order


Syntax: "TUTOR 0.1> SORTW $2000 $3000;A<CR>"
		OR
            "TUTOR 0.1> SORTW $2000 $3000;D<CR>"
		OR
	"TUTOR 0.1> SORTW $2000 $3000<CR>"


In the first example, word sized data stored at addresses $2000-$3000 will be sorted in acending order (based on the mode specified). Similarly, the second example will sort the same data in descending order. There is no mode of operation specified in the third example. Therefore, the default mode of ascending order will be used to sort the data.


How It Works: The "SORTW" (Sort Word) command requires the start and end addresses of the block of memory to be sorted. These are parsed from the user input using the "GET_DATA" subroutine and are then put into two Address Registers. Since this is a word size operation, both the addresses must be even and are therefore checked accordingly. The subroutine then checks if any mode has been entered by the user, which is denoted using the ";" symbol followed by a single uppercase alphabet. Based on this alphabet, the appropriate flag is set. These flags control how the operation is performed (here, ascending/descending order). Therefore, any errors in the inputs causes the subroutine to display an error message on the terminal, and the sort operation is thus not performed. Lastly, if no mode is set, the flag is reset (for default operation of ascending order).


2.2.12.1-) SORTW Algorithm 

Step 1: Save registers to Stack
Step 2: Get start address of block in A1 // Calls subroutine "GET_DATA"
Step 3: IF address is even // Required for word operations
	THEN go to Step 4   
	ELSE go to Step 26 // Invalid Address
Step 4: Get end address of block in A2 // Calls subroutine "GET_DATA"
Step 5: IF address is even // Required for word operations
	THEN go to Step 6   
	ELSE go to Step 26 // Invalid Address
Step 6: Initialize A4-> current position of instruction pointer
Step 7: IF character at (A4) = null    // Check for carriage return
	THEN go to Step 11 // Default order
	ELSE go to Step 8
Step 8: IF character at (A4) = ';'    // Check for semicoln
	THEN go to Step  9
	ELSE go to Step 26  // Invalid command
Step 9: Get mode in D0  // Calls subroutine "GET_MODE"
Step 10: IF D0  = 'A'  
	THEN go to Step 11 // Ascending order
	ELSE go to Step 13
Step 11: Reset flag D2  // Denotes ascending order
Step 12: Go to Step 15
Step 13: IF D0  = 'D'  
	THEN go to Step 14 // Descending order
	ELSE go to Step 26  // Invalid command
Step 14: Set flag D2  // Denotes descending order
Step 15: IF A2 > A1 // Still inside block
	THEN go to Step 16
	ELSE go to Step 19   // Largest word found
Step 16: Get largest word  in D3
Step 17: A1 = A1 + 1  // Increment memory location
Step 18: Go to Step 15  // Loop while inside block
Step 19: Store Largest Number at last address
Step 20: A2 = A2 - 1  // Decrement end address
Step 21: IF A2 = A1 // Block empty
	THEN go to Step 22
	ELSE go to Step 15  // Loop till entire list is in ascending order
Step 22: IF flag set  // Descending order
	THEN go to Step 23
	ELSE go to Step 24  // Operation complete
Step 23: Reverse order entire address range // Calls subroutine "REVERSE"
Step 24: Restore registers from Stack
Step 25: Return from subroutine 
Step 26: Display error message
Step 27: Restore registers from Stack 
Step 28: Return from subroutine 

2.2.12.2-) SORTW Flowchart

2.2.12.3-) SORTWAssembly Code 


*---------------------------------------------------------------------------------------------    
SORTW
* Sorts Word Size Data in Block of Memory
* Ascending/Descending Depending on Mode

    MOVE.L $1030,A0 ; Restore A0 from Memory
    MOVEM.L D0-D2/D6/A0-A4,-(A7) ; Save Registers to Stack

* Get START Address in A1
    LEA DATA1,A0 ; Set Pointer to First Data Save Location
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A1 ; Get First Address in A1, and then Set Pointer to Second Data Save Location
    
* Check if START Address is Even
    MOVE.L A1,D0 ; Get Address in D0
    BTST #0,D0 ; Check if D0 is even
    BNE SORT_INV ; If no, then Address is Invalid

* Get END Address in A2
    JSR GET_DATA ; Get Data from Input
    MOVE.L (A0)+,A2 ; Get Second Address in A2, and then Set Pointer to Third Data Save Location
    
* Check if START Address is Even
    MOVE.L A2,D0 ; Get Address in D0
    BTST #0,D0 ; Check if D0 is even
    BNE SORT_INV ; If no, then Address is Invalid
    
* Check for Order
    LEA INP_PTR,A4 ; Get Address of Input Pointer Location in A4
    MOVE.L (A4),A3 ; Get Current Location of Input Pointer in A3
    
    CMP.B #0,(A3) ; Check if Input String has Ended
    BEQ DEFAULT ; If yes, then Perform Default Operation of Ascending Order
    
    MOVE.L A3,(A4) ; Save Current Input Pointer Location in INP_PTR
  
    JSR GET_MODE ; Get Mode from Input
    MOVE.L (A0),D0 ; Get Third Data in D0
    
    CMP.L #$41,D0 ; Check if Data = 'A'
    BEQ DEFAULT If yes, then Perform Default Operation of Ascending Order
    
    CMP.L #$44,D0 ; Check if Data = 'D'
    BNE SORT_INV ; If no, then Command is Invalid
    
    MOVE.L #1,D2 ; Set Flag for Descending Order
    BRA SORT_START ; Start Sorting Function
  
DEFAULT
    CLR.L D2 ; Reset Flag for Ascending Operation

    JSR CHK_END ; Check if reached end of input. If not, then Command Invalid
    CMP.B #1,D6  ; Check if D6 = 1
    BEQ SORT_INV ; If yes, then Command is Invalid

SORT_START    
    MOVE.L A1,A0 ; Make a Copy of START Address in A0
    CLR.L D0 ; Clear Temporary Register 1
    CLR.L D1 ; Clear Temporary Register 2

OLOOP MOVE.L A1,A3 ; Assuming the First Word is Largest, Set A3 as Pointer
    MOVE.W (A1)+,D0 ; Get Word in D0
    CMP.L A1,A2 ; Check if A2 <= A1
    BLE SORT_END ; If yes, then Sorting Complete

ILOOP MOVE.W (A1)+,D1 ; Get Next Word
    CMP.L D1, D0 ; Compare Previous Word with Next Word
    BGE INEXT ; Check if Previous Word >= Next Word
    MOVE.W -(A1),D0 ; Get Larger Word in D0
    MOVE.L A1,A3 ; Set A3 as Pointer to Larger Word

INEXT CMP.L A1,A2 ; Check if A2 <= A1
    BLE ONEXT ; If yes, then Proceed to Next Round of Sorting
    BRA ILOOP ; If no, then Continue Sorting
    
* Swap the Last Number of the Address Range with the Largest Number in the Current Round, then Shorten the Range by a Word
ONEXT MOVE.W (A3),-(A2)
    MOVE.W D1,(A3)
    
    MOVE.L A0,A1 ; Reload START Address in A1
    
    CMP.L A1,A2 ; Check if A2 > A1
    BGT OLOOP ; If yes, then done    
    
SORT_END CMP.L #1,D2 ; Check if Flag is Set
    BNE SORT_DONE ; If yes, then Sorting Complete
    JSR REVERSE ; If no, then change to Decending Order by Reversing Order

SORT_DONE MOVEM.L (A7)+,D0-D2/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine

SORT_INV JSR INVALID ; Display Error Message
    MOVEM.L (A7)+,D0-D2/D6/A0-A4 ; Restore Registers from Stack
    RTS ; Return from Subroutine
*-----------------------------------------------------------------------------------------------





2.3-) Exception Handlers

During the normal operation of executing one of the existing commands, exceptions could be raised due to invalid inputs or due to executing erroneous code from a memory location using the "GO" command. At such times, rather than being rendered inoperable, the Monitor Program should be able to effectively handle the most common exception and recover from them. The basic exception handling process is as follows:
(1) Store Exception Stack Frame onto the Supervisor Stack
(2) Check the type of exception (Bus Error, Address Error, etc.)
(3) Get the address of the exception handling subroutine from the exception vector table
(4) Execute code at that address


Exception Fig 1


Although the first few steps are the same for all types of exceptions, exception handling routines for each of them are (or can be) different. These subroutines are discussed in the following sections. Lastly, once the exception handling routine has successfully been executed, the data in the registers or memory may have changed. This is due to the fact that there is no method of rolling back changes in the current version of the Monitor Program.

	2.3.1-) Address Error Exception

An Address Error occurs when the user tries to access a word or long size data from an odd address. In the exception handler routine, an error message is displayed, followed by the contents of the Supervisor Status Word, Bus Address and Instruction Register in one line, followed by the contents of all Data and Address Registers in the next. The program then returns to the terminal.

2.3.1.1-) Address Error Exception Flowchart


2.3.1.2-) Address Error Exception Algorithm 

Step 1: Display Error Message 
Step 2: Get Supervisor Status Word, Bus Address & Instruction Register from Stack  // Exception Vector Frame
Step 3: Display Supervisor Status Word, Bus Address & Instruction Register  // In one line
Step 4: Display a carriage return // Display remaining output on next line
Step 5: Display Data and Address Registers // Calls part of DF command
Step 6: Return to terminal



2.3.1.3-) Address Error Exception Assembly Code 

*-----------------------------------------------------------------------------------------------------------
SADR   DC.B 'ADDRESS ERROR OCCURRED!'
       DC.B 0
*-----------------------------------------------------------------------------------------------------------  
ADRS_ERR
    LEA SADR,A1 ; Load Error Message
	
	JSR NEWLINE ; Go to Next Line
    
    MOVE.B #13,D0
    TRAP #15 
    
    MOVE.W (A7)+,D0 ; Throw First Word from Stack
    
    MOVE.L (A7)+,D0 ; Get Bus Address in D0
    MOVE.W (A7)+,D1 ; Get Instruction Register in D1
    
    MOVE.W (A7)+,D2 ; Get Supervisor Status Word in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display SSW
    
    JSR SPACE ; Leave Blank Space
    
    MOVE.l D0,D2 ; Get Bus Address in D2
    MOVE.B #4,D3 ; Set Number of Bytes to Display = 4
    JSR DISPREG ; Display BA
    
    JSR SPACE ; Leave Blank Space
    
    MOVE.l D1,D2 ; Get Instruction Register in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display IR
    
    JSR NEWLINE ; Go to Next Line
    
    MOVE.L (A7)+,D5 ; Throw Long Word from Stack

ERR_DF ; Short Hand Way to Display Data & Address Register Values Using the DF Command

    MOVEM.L A0,-(A7) ; Save A0 on Stack
    
    LEA DATA3,A0 ; Load Address of DATA3 in A0
    MOVE.L A7,(A0) ; Store Value of A7 in DATA3
    ADD.L #4,(A0) ; Get Value of Stack at the Time of Exception
    
    ADD.L #8,A7 ; Move 2 Long Words Down the Stack
    PEA *+22 ; Effective Address to Return from RTS
    SUB.L #4,A7 ; Move 1 Long Word Up the Stack
    
    MOVEM.L (A7)+,A0 ; Restore A0 from Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
    BRA DISP_DA ; Call Part of the DF Command 

    ADD.L #2,A7 ; Throw Long Word from Stack  
    
    BRA RUN_MONITOR ; Return to Terminal
*----------------------------------------------------------------------------------------------------------- 

	2.3.2-) Bus Error Exception

A Bus Error occurs when the user tries to access an invalid or illegal address. In the exception handler routine, an error message is displayed, followed by the contents of the Supervisor Status Word, Bus Address and Instruction Register in one line, followed by the contents of all Data and Address Registers. The program then returns to the terminal.


	2.3.2.1-) Bus Error Exception Flowchart

2.3.2.2-) Bus Error Exception Algorithm

Step 1: Display Error Message 
Step 2: Get Supervisor Status Word, Bus Address & Instruction Register from Stack  // Exception Vector Frame
Step 3: Display Supervisor Status Word, Bus Address & Instruction Register  // In one line
Step 4: Display a carriage return // Display remaining output on next line
Step 5: Display Data and Address Registers // Calls part of DF command
Step 6: Return to terminal


2.3.2.3-) Bus Error Exception Assembly Code 

*-----------------------------------------------------------------------------------------------------------  
SBERR  DC.B 'BUS ERROR OCCURRED!'
       DC.B 0
*-----------------------------------------------------------------------------------------------------------  
BUS_ERR 
    LEA SBERR,A1 ; Load Error Message

	JSR NEWLINE ; Go to Next Line
    
    MOVE.B #13,D0
    TRAP #15 
    
    MOVE.W (A7)+,D0 ; Throw First Word from Stack
    
    MOVE.L (A7)+,D0 ; Get Bus Address in D0
    MOVE.W (A7)+,D1 ; Get Instruction Register in D1
    
    MOVE.W (A7)+,D2 ; Get Supervisor Status Word in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display SSW
    
    JSR SPACE ; Leave Blank Space
    
    MOVE.l D0,D2 ; Get Bus Address in D2
    MOVE.B #4,D3 ; Set Number of Bytes to Display = 4
    JSR DISPREG ; Display BA
    
    JSR SPACE ; Leave Blank Space
    
    MOVE.l D1,D2 ; Get Instruction Register in D2
    MOVE.B #2,D3 ; Set Number of Bytes to Display = 2
    JSR DISPREG ; Display IR
    
    JSR NEWLINE ; Go to Next Line
    
    MOVE.L (A7)+,D5 ; Throw Long Word from Stack

ERR_DF ; Short Hand Way to Display Data & Address Register Values Using the DF Command

    MOVEM.L A0,-(A7) ; Save A0 on Stack
    
    LEA DATA3,A0 ; Load Address of DATA3 in A0
    MOVE.L A7,(A0) ; Store Value of A7 in DATA3
    ADD.L #4,(A0) ; Get Value of Stack at the Time of Exception
    
    ADD.L #8,A7 ; Move 2 Long Words Down the Stack
    PEA *+22 ; Effective Address to Return from RTS
    SUB.L #4,A7 ; Move 1 Long Word Up the Stack
    
    MOVEM.L (A7)+,A0 ; Restore A0 from Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
    BRA DISP_DA ; Call Part of the DF Command 

    ADD.L #2,A7 ; Throw Long Word from Stack  
    
    BRA RUN_MONITOR ; Return to Terminal
*-----------------------------------------------------------------------------------------------------------  


2.3.3-) Illegal Instruction Exception

Illegal instruction is the term used to refer to any of the word bit patterns that do not match the bit pattern of the first word of a legal M68000 instruction. The patterns $4AFA, $4AFB, and $4AFC always cause an Illegal Instruction Exception. In the exception handler routine, an error message is displayed, followed by the contents of all Data and Address Registers. The program then returns to the terminal.

2.3.3.1-) Illegal Instruction Exception Flowchart 
2.3.3.2-) Illegal Instruction Exception Algorithm 

Step 1: Display Error Message 
Step 2: Display Data and Address Registers // Calls part of DF command
Step 3: Return to terminal



2.3.3.3-) Illegal Instruction Exception Assembly Code 

*-----------------------------------------------------------------------------------------------------------  
SILL   DC.B 'ILLEGAL INSTRUCTION ERROR OCCURRED!'
       DC.B 0
*-----------------------------------------------------------------------------------------------------------  
ILL_INST
    LEA SILL,A1 ; Load Error Message
  
	JSR NEWLINE ; Go to Next Line
    MOVE.B #13,D0 ; Display String at A1
    TRAP #15 

ERR_DF ; Short Hand Way to Display Data & Address Register Values Using the DF Command

    MOVEM.L A0,-(A7) ; Save A0 on Stack
    
    LEA DATA3,A0 ; Load Address of DATA3 in A0
    MOVE.L A7,(A0) ; Store Value of A7 in DATA3
    ADD.L #4,(A0) ; Get Value of Stack at the Time of Exception
    
    ADD.L #8,A7 ; Move 2 Long Words Down the Stack
    PEA *+22 ; Effective Address to Return from RTS
    SUB.L #4,A7 ; Move 1 Long Word Up the Stack
    
    MOVEM.L (A7)+,A0 ; Restore A0 from Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
    BRA DISP_DA ; Call Part of the DF Command 

    ADD.L #2,A7 ; Throw Long Word from Stack  
    
    BRA RUN_MONITOR ; Return to Terminal
*-----------------------------------------------------------------------------------------------------------  



2.3.4-) Privilege Violation Exception

To provide system security, various instructions are privileged (RESET, RTE, STOP, and instructions involving SR or USP). An attempt to execute one of the privileged instructions while in the user mode causes an exception. In the exception handler routine, an error message is displayed, followed by the contents of all Data and Address Registers. The program then returns to the terminal.


2.3.4.1-) Privilege Violation Exception Flowchart

2.3.4.2-) Privilege Violation Exception Algorithm

Step 1: Display Error Message 
Step 2: Display Data and Address Registers // Calls part of DF command
Step 3: Return to terminal

2.3.4.3-) Privilege Violation Exception Assembly Code 

*-----------------------------------------------------------------------------------------------------------  
SPRIV  DC.B 'PRIVILEGE VIOLATION ERROR OCCURRED!'
       DC.B 0
*-----------------------------------------------------------------------------------------------------------      
PRIV_VIOL
    LEA SPRIV,A1 ; Load Error Message

	JSR NEWLINE ; Go to Next Line
    MOVE.B #13,D0 ; Display String at A1
    TRAP #15 

ERR_DF ; Short Hand Way to Display Data & Address Register Values Using the DF Command

    MOVEM.L A0,-(A7) ; Save A0 on Stack
    
    LEA DATA3,A0 ; Load Address of DATA3 in A0
    MOVE.L A7,(A0) ; Store Value of A7 in DATA3
    ADD.L #4,(A0) ; Get Value of Stack at the Time of Exception
    
    ADD.L #8,A7 ; Move 2 Long Words Down the Stack
    PEA *+22 ; Effective Address to Return from RTS
    SUB.L #4,A7 ; Move 1 Long Word Up the Stack
    
    MOVEM.L (A7)+,A0 ; Restore A0 from Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
    BRA DISP_DA ; Call Part of the DF Command 

    ADD.L #2,A7 ; Throw Long Word from Stack  
    
    BRA RUN_MONITOR ; Return to Terminal
*-----------------------------------------------------------------------------------------------------------  


2.3.5-) Divide by Zero Exception

When an instructon tries to divide a number by zero, this exception is raised. In the exception handler routine, an error message is displayed, followed by the contents of all Data and Address Registers. The program then returns to the terminal.

2.3.5.1-) Divide by Zero Exception Flowchart


2.3.5.2-) Divide by Zero Exception Algorithm

Step 1: Display Error Message 
Step 2: Display Data and Address Registers // Calls part of DF command
Step 3: Return to terminal

2.3.5.3-) Divide by Zero Exception Assembly Code 

*-----------------------------------------------------------------------------------------------------------  
SZERO  DC.B 'DIVIDE BY ZERO ERROR OCCURRED!'
       DC.B 0
*----------------------------------------------------------------------------------------------------------- 
DIV_ZERO
    LEA SZERO,A1 ; Load Error Message
 
	JSR NEWLINE ; Go to Next Line
    MOVE.B #13,D0 ; Display String at A1
    TRAP #15 

ERR_DF ; Short Hand Way to Display Data & Address Register Values Using the DF Command

    MOVEM.L A0,-(A7) ; Save A0 on Stack
    
    LEA DATA3,A0 ; Load Address of DATA3 in A0
    MOVE.L A7,(A0) ; Store Value of A7 in DATA3
    ADD.L #4,(A0) ; Get Value of Stack at the Time of Exception
    
    ADD.L #8,A7 ; Move 2 Long Words Down the Stack
    PEA *+22 ; Effective Address to Return from RTS
    SUB.L #4,A7 ; Move 1 Long Word Up the Stack
    
    MOVEM.L (A7)+,A0 ; Restore A0 from Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
    BRA DISP_DA ; Call Part of the DF Command 

    ADD.L #2,A7 ; Throw Long Word from Stack  
    
    BRA RUN_MONITOR ; Return to Terminal
*-----------------------------------------------------------------------------------------------------------  
 

2.3.6-) CHK Instruction Exception

The CHK instruction compares the value in the destination data register to zero and to the upper bound source operand. If the register value is less than zero or greater than the upper bound, a CHK Instruction Exception is raised. In the exception handler routine, an error message is displayed, followed by the contents of all Data and Address Registers. The program then returns to the terminal.

2.3.6.1-) CHK Instruction Exception Flowchart


2.3.6.2-) CHK Instruction Exception Algorithm

Step 1: Display Error Message 
Step 2: Display Data and Address Registers // Calls part of DF command
Step 3: Return to terminal

2.3.6.3-) CHK Instruction Exception Assembly Code 

*-----------------------------------------------------------------------------------------------------------  
SCHK   DC.B 'CHK INSTRUCTION ERROR OCCURRED!'
       DC.B 0
       DC.B 0
*-----------------------------------------------------------------------------------------------------------  
CHK_INST
    LEA SCHK,A1 ; Load Error Message

	JSR NEWLINE ; Go to Next Line
    MOVE.B #13,D0 ; Display String at A1
    TRAP #15 

ERR_DF ; Short Hand Way to Display Data & Address Register Values Using the DF Command

    MOVEM.L A0,-(A7) ; Save A0 on Stack
    
    LEA DATA3,A0 ; Load Address of DATA3 in A0
    MOVE.L A7,(A0) ; Store Value of A7 in DATA3
    ADD.L #4,(A0) ; Get Value of Stack at the Time of Exception
    
    ADD.L #8,A7 ; Move 2 Long Words Down the Stack
    PEA *+22 ; Effective Address to Return from RTS
    SUB.L #4,A7 ; Move 1 Long Word Up the Stack
    
    MOVEM.L (A7)+,A0 ; Restore A0 from Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
    BRA DISP_DA ; Call Part of the DF Command 

    ADD.L #2,A7 ; Throw Long Word from Stack  
    
    BRA RUN_MONITOR ; Return to Terminal
*-----------------------------------------------------------------------------------------------------------  



2.3.7-) Line A and Line F Emulators

Word patterns with bits 15-12 equaling 1010 or 1111 are distinguished as unimplemented instructions, and trying to execute these will raise a Line A Emulator Exception or a Line F Emulator Exception respectively.  In the exception handler routine, an error message is displayed, followed by the contents of all Data and Address Registers. The program then returns to the terminal.

2.3.7.1-) Line A and Line F Emulators Flowchart

2.3.7.2-) Line A and Line F Emulators Algorithm 

Step 1: Display Error Message 
Step 2: Display Data and Address Registers // Calls part of DF command
Step 3: Return to terminal

2.3.7.3-) Line A and Line F Emulators Assembly Code 

*-----------------------------------------------------------------------------------------------------------  
SLINEA DC.B 'LINE A EMULATOR ERROR OCCURRED!'
       DC.B 0

SLINEF DC.B 'LINE F EMULATOR ERROR OCCURRED!'
       DC.B 0
       DC.B 0
*-----------------------------------------------------------------------------------------------------------  
LINE_A
    LEA SLINEA,A1 ; Load Error Message
    BRA E_NEXT

LINE_F
    LEA SLINEF,A1 ; Load Error Message

E_NEXT JSR NEWLINE ; Go to Next Line
    MOVE.B #13,D0 ; Display String at A1
    TRAP #15 

ERR_DF ; Short Hand Way to Display Data & Address Register Values Using the DF Command

    MOVEM.L A0,-(A7) ; Save A0 on Stack
    
    LEA DATA3,A0 ; Load Address of DATA3 in A0
    MOVE.L A7,(A0) ; Store Value of A7 in DATA3
    ADD.L #4,(A0) ; Get Value of Stack at the Time of Exception
    
    ADD.L #8,A7 ; Move 2 Long Words Down the Stack
    PEA *+22 ; Effective Address to Return from RTS
    SUB.L #4,A7 ; Move 1 Long Word Up the Stack
    
    MOVEM.L (A7)+,A0 ; Restore A0 from Stack
    
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store All Registers on Stack
    MOVEM.L D0-D7/A0-A6,-(A7) ; Store Another Copy of All Registers on Stack
    
    BRA DISP_DA ; Call Part of the DF Command 

    ADD.L #2,A7 ; Throw Long Word from Stack  
    
    BRA RUN_MONITOR ; Return to Terminal
*-----------------------------------------------------------------------------------------------------------  


2.4-) User Instructional Manual 

The following section describes the short instruction manual that is displayed using the "HELP" command. This section covers the format and types of infomation displayed on the screen for each command.

	2.4.1-) Format

Fig

The first line of the description for any command starts with the name of the command followed by a colon (":"). Next, the function of the command  is described in a few words. If the specific command has multiple modes of operation (such as ascending and descending order for the "Sort Word" command), a list of all the modes, including the default mode is presented on the next few lines. After that, the syntax of the command is presented, which is accompanied by an example usage of the command, which conforms to the syntax. If more than one syntax is valid, each of them is displayed on a new line with an example.

	2.4.2-) Assembly Code

*-----------------------------------------------------------------------------------------------------------  
* Lookup Table for HELP Command
INFO DC.B 'HELP: Displays This Message'
     DC.B  0
     DC.B  0
     DC.B 'MDSP: Displays Addresses And Memory Contents'
     DC.B  0
     DC.B 'MDSP <address1> <address2> eg: MDSP $200 $300<CR>'
     DC.B  0
     DC.B 'MDSP <address1> eg: MDSP $200<CR> (Displays 16 bytes)'
     DC.B  0
     DC.B  0
     DC.B 'MM: Modifies Data In Memory'
     DC.B  0
     DC.B 'Default: Displays One Word'
     DC.B  0
     DC.B ';B: Displays One Byte'
     DC.B  0
     DC.B ';W: Displays One Word'
     DC.B  0
     DC.B ';L: Displays One Long Word'
     DC.B  0
     DC.B 'MM <address1>[;size] eg: MM $8;W<CR>'
     DC.B  0
     DC.B  0
     DC.B 'SORTW: Sorts A Block Of Word Size Memory'
     DC.B  0
     DC.B 'Default: Ascending Order'
     DC.B  0
     DC.B ';A: Ascending Order'
     DC.B  0
     DC.B ';D: Descending Order'
     DC.B  0
     DC.B 'SORTW <address1> <address2>[;size] eg: SORTW $50 $60;A<CR>'
     DC.B  0
     DC.B  0
     DC.B 'MS: Sets Data Into Memory'
     DC.B  0
     DC.B 'MS <address> <data> eg: MS $66 "YAY!"<CR>'
     DC.B  0
     DC.B 'MS <address> <data> eg: MS $66 $455<CR>'
     DC.B  0
     DC.B  0
     DC.B 'UPPER: Capitalizes Null Terminated String At Address'
     DC.B  0
     DC.B 'UPPER <address> eg: UPPER $30<CR>'
     DC.B  0
     DC.B  0
     DC.B 'BF: Fills A Block Of Memory'
     DC.B  0
     DC.B 'BF <address1> <address2> <word> eg: BF $50 $60 $345<CR>'
     DC.B  0
     DC.B  0
     DC.B 'BSCH: Searches A Literal String In Memory'
     DC.B  0
     DC.B 'BSCH <address1> <address2> "string" eg: BSCH $50 $60 "Hey"<CR>'
     DC.B  0
     DC.B  0
     DC.B 'BMOV: Moves A Block Of Memory To Another Area'
     DC.B  0
     DC.B 'BMOV <address1> <address2> <address3> eg: BMOV $20 $30 $40<CR>'
     DC.B  0
     DC.B  0
     DC.B 'BTST: Tests Block Of Memory' 
     DC.B  0
     DC.B 'BTST <address1> <address2> eg: BTST $20 $30<CR>'
     DC.B  0
     DC.B  0
     DC.B 'BREV: Reverses Data In A Block Of Memory'
     DC.B  0
     DC.B 'BREV <address1> <address2> eg: BREV $45 $55<CR>'
     DC.B  0
     DC.B  0
     DC.B 'DF: Displays Formatted Registers'
     DC.B  0
     DC.B 'DF  eg: DF<CR>'
     DC.B  0
     DC.B  0
     DC.B 'GO: Start Execution From Given Address'
     DC.B  0
     DC.B 'GO <address> eg: GO $50<CR>'
     DC.B  0
     DC.B  0
     DC.B 'EXIT: Terminates Monitor Program'
     DC.B  0
     DC.B 'EXIT  eg: EXIT<CR>'
     DC.B  0
     DC.B  0
     DC.B  0
*-----------------------------------------------------------------------------------------------------------  



2.4.3-) Output

Fig





3-) Discussion
 
Considering the superior functionality and ease of use provided by the Monitor Program, it is reasonable to assume that many important design challenges were faced, and these are discussed in this section of the report.

3.1-) Erroneous Inputs & Code Size 

The Monitor Program needs to be able to provide many features to the user. Since, they may not know exactly how the program works, it may happen that the user enters invalid inputs. Thus, the program must be able to handle and recover from these, rather than causing the program to crash. To do so, all possibilities need to be considered and dealt with, which requires both time and effort. But most importantly, enabling subroutines to deal with all kinds of inputs increases the shear volume of the code, which is not an appealling feature. Therefore, effort needs to be taken to find a balance between functionality and code size, which has been addressed as much as possible in the implementation of the Montor Program.

3.2-) Stack Operations

Since the Monitor Program is basically comprised of a whole bunch of subroutines and branches between them, for the most part (as far as implementation is concerned) the Stack is constantly being used to store return PC locations (in the case of JSR - Jump to Subroutine), save register values (to prevent changes made during subroutine operation), and to place the exception stack frame (during exception handling). As there are all these different types of data on the Stack, it is crucial to keep track of what is actually on there, and what needs to be removed from it at any point during the code. This makes it quite challenging for the programmer to implement the many subroutines as a single extra (or less) data on the Stack can cause a whole bunch of exceptions, thus making the Monitor Program inoperable.

3.3-) Looking for Logic Errors

The Easy68K simulator is equipped with a compiler which checks for any syntax errors and warns the programmer about it. However, logic errors are not that easy to locate, and considering the large size of the code, and since the program involves a large number of brances and returns, this problem is compounded even further. A simple logic error in a single line of code could generate a large number of exceptions (at times, the simulator might even halt). But in order to find the instruction where the logic is flawed, the programmer must trace through the entire code (including the branches) to pinpoint its location (as the error could be in any of the subroutines the program branches through). Thus, the programmer needs to put in a lot more time and effort to fix errors in the Monitor Program code as compared to when writing simple, shorter programs.

3.4-) Limited Implementation

Some of the commands in the existing Monitor Program are limited in nature. For example, the BF (Block Fill) command fills a block of memory with word size data. For proper functionality, the addresses need to be even, or else an address error will occur. Thus, if the user wishes to fill byte size data in a range of odd number of addresses, there is no way for them to do so without affecting the following (or preceding) memory location. A few other commands have this same issue and could therefore be improved upon.



4-) Feature Suggestions 

Although the current version of the Monitor Program is well implemented and robust, there are certain modifications that can make the program even more efficient and thus increase user satisfaction. These are discussed in this section of the report.

4.1-) Segmented "HELP" Command

When the user enters commands into the terminal, they might have trouble remembering the exact syntax for a specific command. The user could also be curious to see what capabilities the command allows them (such as the kinds of data that are valid, their different combinations, and so on) so that they may be able to use the Monitor Program to the greatest possible extent. In both these cases, the user only needs a description of the one command and not all. However, when the "HELP" command is inputted, it displays an entire block of information that includes descriptions for all commands. This can be improved by adding an argument to the "HELP" command that would include the name of the command the user wants to know more about. For example, they could enter "HELP MDSP" to get information about the "MDSP" (Memory Display). Adding this feature would surely help the user to be able to use the Monitor Program more efficiently.

4.2-) Enhanced "MDSP" (Memory Display) Command

The "MDSP" (Memory Display) command is used to display the addresses and the contents of memory locataions between two inputted addresses. When the user enters a large range (Like $2000 to $3000), the screen gets rapidly filled up will all the output data, most of which may not fit in the screen. Thus, to prevent this, two suggestions are made. Firstly, the "MDSP" command could be modified to output data from consecutive addresses after certain intervals of time. For example, it could output upto 16 consecutive memory locations, and then wait for a short amount of time before outputting the next set of data. Another, more efficient way of dealing with this situation is to perform the exact same operation as the first suggestion, but instead of waiting for a short amount of time, the program could wait for user input (such as a carriage return) before displaying the next set of data. Incorporating this into the command will improve its efficiency and usability when working with large address ranges.

4.3-) A String Display Command

The "MS" (Memory Set) command can be used to store an inputted string literal in memory. However, in the current version of the Monitor Program, there is no way to display a string from memory. The only current method of checking if the string was correctly stored in memory is by using the "BSCH" (Block Search) command. However, the user needs to know the exact (or at least partial) string to look for. So it cannot be used to display unknown strings from a particular memory location. Adding this feature would therefore benefit the user when used in conjugation with commands that work on strings (for example converting a string to uppercase/lowercase, reversing a string).

4.4-) A Repeat Command

There are instances when the user may want to perform the same operation repeatedly. To do so, they have to enter the command over and over again, which is not practical. Thus, a command could be added to the Monitor Program that repeats whatever last command the user entered. 

4.5-) Additional Commands

As the scope of this Monitor Program is limited in nature, only a select few commands were implemented. However, a whole bunch of commands could be added to make the software more beneficial to the user. This could include string commands -- converting a string to uppercase/lowercase, reversing a string, replaces a string, etc. -- math operations -- a simple calculator command capable of performing addition, subtraction, multiplication, division and exponents -- or even trigonometry operations -- sine, cosine, tangent, etc. Adding these will enable to user to utilize the Monitor Program in more advanced ways that the current version simply cannot afford.


 

5-) Conclusion 

	The Monitor Program is intended to enable a user who does not have the time or effort to write long programs to be able to perform their required operations using short and simple commands. As discussed in the report, the current version of the Monitor Program provides 12 usuable commands. Each of them has been extensively discussed within the course of this report with the help of flowcharts, algorithms and assembly code. In the concluding sections, a discussion on the design challenges faced and feature suggestions have also been included to push for future works building on the current design. The implemented monitor program was tested for its functionality as well as its error-handling capabilities. In short, utmost efforts were made to provide the user with the most efficient and easy-to-use Monitor Program.
	
6-) References

[1]	https://smallbusiness.chron.com/common-uses-microprocessors-69828.html

[2]	http://www.easy68k.com/